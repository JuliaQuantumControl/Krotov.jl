<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>- · Krotov.jl</title><meta name="title" content="- · Krotov.jl"/><meta property="og:title" content="- · Krotov.jl"/><meta property="twitter:title" content="- · Krotov.jl"/><meta name="description" content="Documentation for Krotov.jl."/><meta property="og:description" content="Documentation for Krotov.jl."/><meta property="twitter:description" content="Documentation for Krotov.jl."/><meta property="og:url" content="https://juliaquantumcontrol.github.io/Krotov.jl/externals/"/><meta property="twitter:url" content="https://juliaquantumcontrol.github.io/Krotov.jl/externals/"/><link rel="canonical" href="https://juliaquantumcontrol.github.io/Krotov.jl/externals/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/><link href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/assets/topbar/topbar.css" rel="stylesheet" type="text/css"/><script src="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/assets/topbar/topbar.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Krotov.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../references/">References</a></li><li class="is-active"><a class="tocitem" href>-</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>-</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>-</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaQuantumControl/Krotov.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaQuantumControl/Krotov.jl/blob/master/docs/src/externals.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControlBase.ControlProblem" href="#QuantumControlBase.ControlProblem"><code>QuantumControlBase.ControlProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A full control problem with multiple trajectories.</p><pre><code class="language-julia hljs">ControlProblem(
   trajectories,
   tlist;
   kwargs...
)</code></pre><p>The <code>trajectories</code> are a list of <a href="#QuantumControlBase.Trajectory"><code>Trajectory</code></a> instances, each defining an initial state and a dynamical generator for the evolution of that state. Usually, the trajectory will also include a target state (see <a href="#QuantumControlBase.Trajectory"><code>Trajectory</code></a>) and possibly a weight. The <code>trajectories</code> may also be given together with <code>tlist</code> as a mandatory keyword argument.</p><p>The <code>tlist</code> is the time grid on which the time evolution of the initial states of each trajectory should be propagated. It may also be given as a (mandatory) keyword argument.</p><p>The remaining <code>kwargs</code> are keyword arguments that are passed directly to the optimal control method. These typically include e.g. the optimization functional.</p><p>The control problem is solved by finding a set of controls that minimize an optimization functional over all trajectories.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/v0.10.0+dev/src/control_problem.jl#L4-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControlBase.Trajectory" href="#QuantumControlBase.Trajectory"><code>QuantumControlBase.Trajectory</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Description of a state&#39;s time evolution.</p><pre><code class="language-julia hljs">Trajectory(
    initial_state,
    generator;
    target_state=nothing,
    weight=1.0,
    kwargs...
)</code></pre><p>describes the time evolution of the <code>initial_state</code> under a time-dependent dynamical <code>generator</code> (e.g., a Hamiltonian or Liouvillian).</p><p>Trajectories are central to quantum control problems: an optimization functional depends on the result of propagating one or more trajectories. For example, when optimizing for a quantum gate, the optimization considers the trajectories of all logical basis states.</p><p>In addition to the <code>initial_state</code> and <code>generator</code>, a <code>Trajectory</code> may include data relevant to the propagation and to evaluating a particular optimization functional. Most functionals have the notion of a &quot;target state&quot; that the <code>initial_state</code> should evolve towards, which can be given as the <code>target_state</code> keyword argument. In some functionals, different trajectories enter with different weights [<a href="../references/#GoerzNJP2014">8</a>], which can be given as a <code>weight</code> keyword argument. Any other keyword arguments are also available to a functional as properties of the <code>Trajectory</code> .</p><p>A <code>Trajectory</code> can also be instantiated using all keyword arguments.</p><p><strong>Properties</strong></p><p>All keyword arguments used in the instantiation are available as properties of the <code>Trajectory</code>. At a minimum, this includes <code>initial_state</code>, <code>generator</code>, <code>target_state</code>, and <code>weight</code>.</p><p>By convention, properties with a <code>prop_</code> prefix, e.g., <code>prop_method</code>, will be taken into account when propagating the trajectory. See <a href="#QuantumControlBase.propagate_trajectory-Tuple{Any, Any}"><code>propagate_trajectory</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/v0.10.0+dev/src/trajectories.jl#L9-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.adjoint-Tuple{Trajectory}" href="#Base.adjoint-Tuple{Trajectory}"><code>Base.adjoint</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct the adjoint of a <a href="#QuantumControlBase.Trajectory"><code>Trajectory</code></a>.</p><pre><code class="language-julia hljs">adj_trajectory = adjoint(trajectory)</code></pre><p>The adjoint trajectory contains the adjoint of the dynamical generator <code>traj.generator</code>. All other fields contain a copy of the original field value.</p><p>The primary purpose of this adjoint is to facilitate the backward propagation under the adjoint generator that is central to gradient-based optimization methods such as GRAPE and Krotov&#39;s method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/v0.10.0+dev/src/trajectories.jl#L238-L252">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControlBase.chain_callbacks-Tuple" href="#QuantumControlBase.chain_callbacks-Tuple"><code>QuantumControlBase.chain_callbacks</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Combine multiple <code>callback</code> functions.</p><pre><code class="language-julia hljs">chain_callbacks(funcs...)</code></pre><p>combines <code>funcs</code> into a single Function that can be passes as <code>callback</code> to <a href="#QuantumControlBase.ControlProblem"><code>ControlProblem</code></a> or any <code>optimize</code>-function.</p><p>Each function in <code>func</code> must be a suitable <code>callback</code> by itself. This means that it should receive the optimization workspace object as its first positional parameter, then positional parameters specific to the optimization method, and then an arbitrary number of data parameters. It must return either <code>nothing</code> or a tuple of &quot;info&quot; objects (which will end up in the <code>records</code> field of the optimization result).</p><p>When chaining callbacks, the <code>funcs</code> will be called in series, and the &quot;info&quot; objects will be accumulated into a single result tuple. The combined results from previous <code>funcs</code> will be given to the subsequent <code>funcs</code> as data parameters. This allows for the callbacks in the chain to communicate.</p><p>The chain will return the final combined result tuple, or <code>nothing</code> if all <code>funcs</code> return <code>nothing</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>When calling <a href="../api/#QuantumControlBase.optimize-Tuple{Any, Val{:Krotov}}"><code>optimize</code></a>, any <code>callback</code> that is a tuple will be automatically processed with <code>chain_callbacks</code>. Thus, <code>chain_callbacks</code> rarely has to be invoked manually.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/v0.10.0+dev/src/callbacks.jl#L36-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControlBase.check_amplitude-Tuple{Any}" href="#QuantumControlBase.check_amplitude-Tuple{Any}"><code>QuantumControlBase.check_amplitude</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Check an amplitude in a <a href="#QuantumPropagators.Generators.Generator"><code>Generator</code></a> in the context of optimal control.</p><pre><code class="nohighlight hljs">@test check_amplitude(
    ampl; tlist, for_gradient_optimization=true, quiet=false
)</code></pre><p>verifies that the given <code>ampl</code> is a valid element in the list of <code>amplitudes</code> of a <a href="#QuantumPropagators.Generators.Generator"><code>Generator</code></a> object. This checks all the conditions of <a href="#QuantumPropagators.Interfaces.check_amplitude-Tuple{Any}"><code>QuantumPropagators.Interfaces.check_amplitude</code></a>. In addition, the following conditions must be met.</p><p>If <code>for_gradient_optimization</code>:</p><ul><li>The function <a href="#QuantumControlBase.get_control_deriv-Tuple{Function, Any}"><code>get_control_deriv(ampl, control)</code></a> must be defined</li><li>If <code>ampl</code> does not depend on <code>control</code>, <a href="#QuantumControlBase.get_control_deriv-Tuple{Function, Any}"><code>get_control_deriv(ampl, control)</code></a> must return <code>0.0</code></li><li>If <code>ampl</code> depends on <code>control</code>, <a href="#QuantumControlBase.get_control_deriv-Tuple{Function, Any}"><code>get_control_deriv(ampl, control)</code></a> must return an object <code>u</code> so that <code>evaluate(u, tlist, n)</code> returns a Number. In most cases, <code>u</code> itself will be a Number.</li></ul><p>The function returns <code>true</code> for a valid amplitude and <code>false</code> for an invalid amplitude. Unless <code>quiet=true</code>, it will log an error to indicate which of the conditions failed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/v0.10.0+dev/src/check_amplitude.jl#L7-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControlBase.check_generator-Tuple{Any}" href="#QuantumControlBase.check_generator-Tuple{Any}"><code>QuantumControlBase.check_generator</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Check the dynamical <code>generator</code> in the context of optimal control.</p><pre><code class="nohighlight hljs">@test check_generator(
    generator; state, tlist,
    for_expval=true, for_pwc=true, for_time_continuous=false,
    for_parameterization=false, for_gradient_optimization=true,
    atol=1e-15, quiet=false
)</code></pre><p>verifies the given <code>generator</code>. This checks all the conditions of <a href="#QuantumPropagators.Interfaces.check_generator-Tuple{Any}"><code>QuantumPropagators.Interfaces.check_generator</code></a>. In addition, the following conditions must be met.</p><p>If <code>for_gradient_optimization</code>:</p><ul><li><a href="#QuantumControlBase.get_control_derivs-Tuple{Any, Any}"><code>get_control_derivs(generator, controls)</code></a> must be defined and return a vector containing the result of <a href="#QuantumControlBase.get_control_deriv-Tuple{Function, Any}"><code>get_control_deriv(generator, control)</code></a> for every <code>control</code> in <code>controls</code>.</li><li><a href="#QuantumControlBase.get_control_deriv-Tuple{Function, Any}"><code>get_control_deriv(generator, control)</code></a> must return an object that passes the less restrictive <a href="#QuantumPropagators.Interfaces.check_generator-Tuple{Any}"><code>QuantumPropagators.Interfaces.check_generator</code></a> if <code>control</code> is in <code>get_controls(generator)</code>.</li><li><a href="#QuantumControlBase.get_control_deriv-Tuple{Function, Any}"><code>get_control_deriv(generator, control)</code></a> must return <code>nothing</code> if <code>control</code> is not in <a href="#QuantumPropagators.Controls.get_controls-Tuple{ControlProblem}"><code>get_controls(generator)</code></a></li><li>If <code>generator</code> is a <a href="#QuantumPropagators.Generators.Generator"><code>Generator</code></a> instance, every <code>ampl</code> in <code>generator.amplitudes</code> must pass <a href="#QuantumControlBase.check_amplitude-Tuple{Any}"><code>check_amplitude(ampl; tlist)</code></a>.</li></ul><p>The function returns <code>true</code> for a valid generator and <code>false</code> for an invalid generator. Unless <code>quiet=true</code>, it will log an error to indicate which of the conditions failed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/v0.10.0+dev/src/check_generator.jl#L8-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControlBase.get_control_deriv-Tuple{Function, Any}" href="#QuantumControlBase.get_control_deriv-Tuple{Function, Any}"><code>QuantumControlBase.get_control_deriv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">a = get_control_deriv(ampl, control)</code></pre><p>returns the derivative <span>$∂a_l(t)/∂ϵ_{l&#39;}(t)$</span> of the given amplitude <span>$a_l(\{ϵ_{l&#39;&#39;}(t)\}, t)$</span> with respect to the given control <span>$ϵ_{l&#39;}(t)$</span>. For &quot;trivial&quot; amplitudes, where <span>$a_l(t) ≡ ϵ_l(t)$</span>, the result with be either <code>1.0</code> or <code>0.0</code> (depending on whether <code>ampl ≡ control</code>). For non-trivial amplitudes, the result may be another amplitude that depends on the controls and potentially on time, but can be evaluated to a constant with <a href="#QuantumPropagators.Controls.evaluate-Tuple{Any, Vararg{Any}}"><code>evaluate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/v0.10.0+dev/src/derivs.jl#L79-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControlBase.get_control_deriv-Tuple{Tuple, Any}" href="#QuantumControlBase.get_control_deriv-Tuple{Tuple, Any}"><code>QuantumControlBase.get_control_deriv</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the derivative of the generator <span>$G$</span> w.r.t. the control <span>$ϵ(t)$</span>.</p><pre><code class="language-julia hljs">μ  = get_control_deriv(generator, control)</code></pre><p>returns <code>nothing</code> if the <code>generator</code> (Hamiltonian or Liouvillian) does not depend on <code>control</code>, or a generator</p><p class="math-container">\[μ = \frac{∂G}{∂ϵ(t)}\]</p><p>otherwise. For linear control terms, <code>μ</code> will be a static operator, e.g. an <code>AbstractMatrix</code> or an <a href="#QuantumPropagators.Generators.Operator"><code>Operator</code></a>. For non-linear controls, <code>μ</code> will be time-dependent, e.g. a <a href="#QuantumPropagators.Generators.Generator"><code>Generator</code></a>. In either case, <a href="#QuantumPropagators.Controls.evaluate-Tuple{Any, Vararg{Any}}"><code>evaluate</code></a> should be used to evaluate <code>μ</code> into a constant operator for particular values of the controls and a particular point in time.</p><p>For constant generators, e.g. an <a href="#QuantumPropagators.Generators.Operator"><code>Operator</code></a>, the result is always <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/v0.10.0+dev/src/derivs.jl#L29-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControlBase.get_control_derivs-Tuple{Any, Any}" href="#QuantumControlBase.get_control_derivs-Tuple{Any, Any}"><code>QuantumControlBase.get_control_derivs</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get a vector of the derivatives of <code>generator</code> w.r.t. each control.</p><pre><code class="language-julia hljs">get_control_derivs(generator, controls)</code></pre><p>return as vector containing the derivative of <code>generator</code> with respect to each control in <code>controls</code>. The elements of the vector are either <code>nothing</code> if <code>generator</code> does not depend on that particular control, or a function <code>μ(α)</code> that evaluates the derivative for a particular value of the control, see <a href="#QuantumControlBase.get_control_deriv-Tuple{Function, Any}"><code>get_control_deriv</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/v0.10.0+dev/src/derivs.jl#L5-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControlBase.init_prop_trajectory-Tuple{Trajectory, Any}" href="#QuantumControlBase.init_prop_trajectory-Tuple{Trajectory, Any}"><code>QuantumControlBase.init_prop_trajectory</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Initialize a propagator for a given <a href="#QuantumControlBase.Trajectory"><code>Trajectory</code></a>.</p><pre><code class="nohighlight hljs">propagator = init_prop_trajectory(
    traj,
    tlist;
    initial_state=traj.initial_state,
    kwargs...
)</code></pre><p>initializes a <a href="#QuantumPropagators.AbstractPropagator"><code>Propagator</code></a> for the propagation of the <code>initial_state</code> under the dynamics described by <code>traj.generator</code>.</p><p>All keyword arguments are forwarded to <a href="#QuantumPropagators.init_prop-Tuple{Any, Any, Any, Val{:Cheby}}"><code>QuantumPropagators.init_prop</code></a>, with default values from any property of <code>traj</code> with a <code>prop_</code> prefix. That is, the keyword arguments for the underlying <a href="#QuantumPropagators.init_prop-Tuple{Any, Any, Any, Val{:Cheby}}"><code>QuantumPropagators.init_prop</code></a> are determined as follows:</p><ul><li>For any property of <code>traj</code> whose name starts with the prefix <code>prop_</code>, strip the prefix and use that property as a keyword argument for <code>init_prop</code>. For example, if <code>traj.prop_method</code> is defined, <code>method=traj.prop_method</code> will be passed to <code>init_prop</code>. Similarly, <code>traj.prop_inplace</code> would be passed as <code>inplace=traj.prop_inplace</code>, etc.</li><li>Any explicitly keyword argument to <code>init_prop_trajectory</code> overrides the values from the properties of <code>traj</code>.</li></ul><p>Note that the propagation <code>method</code> in particular must be specified, as it is a mandatory keyword argument in <a href="#QuantumPropagators.propagate-Tuple{Any, Any, Any}"><code>QuantumPropagators.propagate</code></a>). Thus, either <code>traj</code> must have a property <code>prop_method</code> of the trajectory, or <code>method</code> must be given as an explicit keyword argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/v0.10.0+dev/src/propagate.jl#L62-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControlBase.make_chi-Tuple{Any, Any}" href="#QuantumControlBase.make_chi-Tuple{Any, Any}"><code>QuantumControlBase.make_chi</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a function that calculates <span>$|χ_k⟩ = -∂J_T/∂⟨Ψ_k|$</span>.</p><pre><code class="language-julia hljs">chi = make_chi(
    J_T,
    trajectories;
    mode=:any,
    automatic=:default,
    via=(any(isnothing(t.target_state) for t in trajectories) ? :states : :tau),
)</code></pre><p>creates a function <code>chi(Ψ, trajectories; τ)</code> that returns a vector of states <code>χ</code> with <span>$|χ_k⟩ = -∂J_T/∂⟨Ψ_k|$</span>, where <span>$|Ψ_k⟩$</span> is the k&#39;th element of <code>Ψ</code>. These are the states used as the boundary condition for the backward propagation propagation in Krotov&#39;s method and GRAPE. Each <span>$|χₖ⟩$</span> is defined as a matrix calculus <a href="https://www.ekinakyurek.me/complex-derivatives-wirtinger/">Wirtinger derivative</a>,</p><p class="math-container">\[|χ_k(T)⟩ = -\frac{∂J_T}{∂⟨Ψ_k|} = -\frac{1}{2} ∇_{Ψ_k} J_T\,;\qquad
∇_{Ψ_k} J_T ≡ \frac{∂J_T}{\Re[Ψ_k]} + i \frac{∂J_T}{\Im[Ψ_k]}\,.\]</p><p>The function <code>J_T</code> must take a vector of states <code>Ψ</code> and a vector of <code>trajectories</code> as positional parameters. If <code>via=:tau</code>, it must also a vector <code>tau</code> as a keyword argument, see e.g. <code>J_T_sm</code>). that contains the overlap of the states <code>Ψ</code> with the target states from the <code>trajectories</code></p><p>The derivative can be calculated analytically of automatically (via automatic differentiation) depending on the value of <code>mode</code>. For <code>mode=:any</code>, an analytic derivative is returned if available, with a fallback to an automatic derivative.</p><p>If <code>mode=:analytic</code>, return an analytically known <span>$-∂J_T/∂⟨Ψ_k|$</span>, e.g.,</p><ul><li><a href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/api/quantum_control_reference/#QuantumControl.Functionals.J_T_sm"><code>QuantumControl.Functionals.J_T_sm</code></a> → <a href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/api/quantum_control_reference/#QuantumControl.Functionals.chi_sm"><code>QuantumControl.Functionals.chi_sm</code></a>,</li><li><a href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/api/quantum_control_reference/#QuantumControl.Functionals.J_T_re"><code>QuantumControl.Functionals.J_T_re</code></a> → <a href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/api/quantum_control_reference/#QuantumControl.Functionals.chi_re"><code>QuantumControl.Functionals.chi_re</code></a>,</li><li><a href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/api/quantum_control_reference/#QuantumControl.Functionals.J_T_ss"><code>QuantumControl.Functionals.J_T_ss</code></a> → <a href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/api/quantum_control_reference/#QuantumControl.Functionals.chi_ss"><code>QuantumControl.Functionals.chi_ss</code></a>.</li></ul><p>and throw an error if no analytic derivative is known.</p><p>If <code>mode=:automatic</code>, return an automatic derivative (even if an analytic derivative is known). The calculation of an automatic derivative  (whether via <code>mode=:any</code> or <code>mode=:automatic</code>) requires that a suitable framework (e.g., <code>Zygote</code> or <code>FiniteDifferences</code>) has been loaded. The loaded module must be passed as <code>automatic</code> keyword argument. Alternatively, it can be registered as a default value for <code>automatic</code> by calling <code>QuantumControl.set_default_ad_framework</code>.</p><p>When evaluating <span>$|χ_k⟩$</span> automatically, if <code>via=:states</code> is given , <span>$|χ_k(T)⟩$</span> is calculated directly as defined above from the gradient with respect to the states <span>$\{|Ψ_k(T)⟩\}$</span>.</p><p>If <code>via=:tau</code> is given instead, the functional <span>$J_T$</span> is considered a function of overlaps <span>$τ_k = ⟨Ψ_k^\tgt|Ψ_k(T)⟩$</span>. This requires that all <code>trajectories</code> define a <code>target_state</code> and that <code>J_T</code> calculates the value of the functional solely based on the values of <code>tau</code> passed as a keyword argument.  With only the complex conjugate <span>$τ̄_k = ⟨Ψ_k(T)|Ψ_k^\tgt⟩$</span> having an explicit dependency on <span>$⟨Ψ_k(T)|$</span>,  the chain rule in this case is</p><p class="math-container">\[|χ_k(T)⟩
= -\frac{∂J_T}{∂⟨Ψ_k|}
= -\left(
    \frac{∂J_T}{∂τ̄_k}
    \frac{∂τ̄_k}{∂⟨Ψ_k|}
  \right)
= - \frac{1}{2} (∇_{τ_k} J_T) |Ψ_k^\tgt⟩\,.\]</p><p>Again, we have used the definition of the Wirtinger derivatives,</p><p class="math-container">\[\begin{align*}
    \frac{∂J_T}{∂τ_k}
    &amp;≡ \frac{1}{2}\left(
        \frac{∂ J_T}{∂ \Re[τ_k]}
        - i \frac{∂ J_T}{∂ \Im[τ_k]}
    \right)\,,\\
    \frac{∂J_T}{∂τ̄_k}
    &amp;≡ \frac{1}{2}\left(
        \frac{∂ J_T}{∂ \Re[τ_k]}
        + i \frac{∂ J_T}{∂ \Im[τ_k]}
    \right)\,,
\end{align*}\]</p><p>and the definition of the Zygote gradient with respect to a complex scalar,</p><p class="math-container">\[∇_{τ_k} J_T = \left(
    \frac{∂ J_T}{∂ \Re[τ_k]}
    + i \frac{∂ J_T}{∂ \Im[τ_k]}
\right)\,.\]</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>In order to extend <code>make_chi</code> with an analytic implementation for a new <code>J_T</code> function, define a new method <code>make_analytic_chi</code> like so:</p><pre><code class="language-julia hljs">QuantumControlBase.make_analytic_chi(::typeof(J_T_sm), trajectories) = chi_sm</code></pre><p>which links <code>make_chi</code> for <a href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/api/quantum_control_reference/#QuantumControl.Functionals.J_T_sm"><code>QuantumControl.Functionals.J_T_sm</code></a> to <a href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/api/quantum_control_reference/#QuantumControl.Functionals.chi_sm"><code>QuantumControl.Functionals.chi_sm</code></a>.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Zygote is notorious for being buggy (silently returning incorrect gradients). Always test automatic derivatives against finite differences and/or other automatic differentiation frameworks.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/v0.10.0+dev/src/functionals.jl#L73-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControlBase.make_grad_J_a-Tuple{Any, Any}" href="#QuantumControlBase.make_grad_J_a-Tuple{Any, Any}"><code>QuantumControlBase.make_grad_J_a</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a function to evaluate <span>$∂J_a/∂ϵ_{ln}$</span> for a pulse value running cost.</p><pre><code class="language-julia hljs">grad_J_a! = make_grad_J_a(
    J_a,
    tlist;
    mode=:any,
    automatic=:default,
)</code></pre><p>returns a function so that <code>grad_J_a!(∇J_a, pulsevals, tlist)</code> sets <span>$∂J_a/∂ϵ_{ln}$</span> as the elements of the (vectorized) <code>∇J_a</code>. The function <code>J_a</code> must have the interface <code>J_a(pulsevals, tlist)</code>, see, e.g., <code>J_a_fluence</code>.</p><p>The parameters <code>mode</code> and <code>automatic</code> are handled as in <a href="#QuantumControlBase.make_chi-Tuple{Any, Any}"><code>make_chi</code></a>, where <code>mode</code> is one of <code>:any</code>, <code>:analytic</code>, <code>:automatic</code>, and <code>automatic</code> is he loaded module of an automatic differentiation framework, where <code>:default</code> refers to the framework set with <code>QuantumControl.set_default_ad_framework</code>.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>In order to extend <code>make_grad_J_a</code> with an analytic implementation for a new <code>J_a</code> function, define a new method <code>make_analytic_grad_J_a</code> like so:</p><pre><code class="language-julia hljs">make_analytic_grad_J_a(::typeof(J_a_fluence), tlist) = grad_J_a_fluence!</code></pre><p>which links <code>make_grad_J_a</code> for <code>J_a_fluence</code> to <code>grad_J_a_fluence!</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/v0.10.0+dev/src/functionals.jl#L308-L340">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControlBase.make_print_iters-Tuple{Module}" href="#QuantumControlBase.make_print_iters-Tuple{Module}"><code>QuantumControlBase.make_print_iters</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct a method-specific automatic callback for printing iter information.</p><pre><code class="language-julia hljs">print_iters = make_print_iters(Method; kwargs...)</code></pre><p>constructs the automatic callback to be used by <code>optimize(problem; method=Method, print_iters=true)</code> to print information after each iteration. The keyword arguments are those used to instantiate <code>problem</code> and those explicitly passed to <a href="../api/#QuantumControlBase.optimize-Tuple{Any, Val{:Krotov}}"><code>optimize</code></a>.</p><p>Optimization methods should implement <code>make_print_iters(::Val{:Method}; kwargs...)</code> where <code>:Method</code> is the name of the module/package implementing the method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/v0.10.0+dev/src/callbacks.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControlBase.optimize-Tuple{ControlProblem}" href="#QuantumControlBase.optimize-Tuple{ControlProblem}"><code>QuantumControlBase.optimize</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Optimize a quantum control problem.</p><pre><code class="language-julia hljs">result = optimize(
    problem;
    method,  # mandatory keyword argument
    check=true,
    callback=nothing,
    print_iters=true,
    kwargs...
)</code></pre><p>optimizes towards a solution of given <a href="#QuantumControlBase.ControlProblem"><code>problem</code></a> with the given <code>method</code>, which should be a <code>Module</code> implementing the method, e.g.,</p><pre><code class="language-julia hljs">using Krotov
result = optimize(problem; method=Krotov)</code></pre><p>If <code>check</code> is true (default), the <code>initial_state</code> and <code>generator</code> of each trajectory is checked with <a href="#QuantumPropagators.Interfaces.check_state-Tuple{Any}"><code>check_state</code></a> and <a href="#QuantumControlBase.check_generator-Tuple{Any}"><code>check_generator</code></a>. Any other keyword argument temporarily overrides the corresponding keyword argument in <a href="#QuantumControlBase.ControlProblem"><code>problem</code></a>. These arguments are available to the optimizer, see each optimization package&#39;s documentation for details.</p><p>The <code>callback</code> can be given as a function to be called after each iteration in order to analyze the progress of the optimization or to modify the state of the optimizer or the current controls. The signature of <code>callback</code> is method-specific, but callbacks should receive a workspace objects as the first parameter as the first argument, the iteration number as the second parameter, and then additional method-specific parameters.</p><p>The <code>callback</code> function may return a tuple of values, and an optimization method should store these values fore each iteration in a <code>records</code> field in their <code>Result</code> object. The <code>callback</code> should be called once with an iteration number of <code>0</code> before the first iteration. The <code>callback</code> can also be given as a tuple of vector of functions, which are automatically combined via <a href="#QuantumControlBase.chain_callbacks-Tuple"><code>chain_callbacks</code></a>.</p><p>If <code>print_iters</code> is <code>true</code> (default), an automatic <code>callback</code> is created via the method-specific <a href="#QuantumControlBase.make_print_iters-Tuple{Module}"><code>make_print_iters</code></a> to print the progress of the optimization after each iteration. This automatic callback runs after any manually given <code>callback</code>.</p><p>All remaining keyword argument are method-specific. To obtain the documentation for which options a particular method uses, run, e.g.,</p><pre><code class="language-julia hljs">? optimize(problem, ::Val{:Krotov})</code></pre><p>where <code>:Krotov</code> is the name of the module implementing the method. The above is also the method signature that a <code>Module</code> wishing to implement a control method must define.</p><p>The returned <code>result</code> object is specific to the optimization method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/v0.10.0+dev/src/optimize.jl#L11-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControlBase.propagate_trajectories-Tuple{Any, Any}" href="#QuantumControlBase.propagate_trajectories-Tuple{Any, Any}"><code>QuantumControlBase.propagate_trajectories</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Propagate multiple trajectories in parallel.</p><pre><code class="language-julia hljs">result = propagate_trajectories(
    trajectories, tlist; use_threads=true, kwargs...
)</code></pre><p>runs <a href="#QuantumControlBase.propagate_trajectory-Tuple{Any, Any}"><code>propagate_trajectory</code></a> for every trajectory in <code>trajectories</code>, collects and returns a vector of results. The propagation happens in parallel if <code>use_threads=true</code> (default). All keyword parameters are passed to <a href="#QuantumControlBase.propagate_trajectory-Tuple{Any, Any}"><code>propagate_trajectory</code></a>, except that if <code>initial_state</code> is given, it must be a vector of initial states, one for each trajectory. Likewise, to pass pre-allocated storage arrays to <code>storage</code>, a vector of storage arrays must be passed. A simple <code>storage=true</code> will still work to return a vector of storage results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/v0.10.0+dev/src/propagate.jl#L153-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControlBase.propagate_trajectory-Tuple{Any, Any}" href="#QuantumControlBase.propagate_trajectory-Tuple{Any, Any}"><code>QuantumControlBase.propagate_trajectory</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Propagate a <a href="#QuantumControlBase.Trajectory"><code>Trajectory</code></a>.</p><pre><code class="language-julia hljs">propagate_trajectory(
    traj,
    tlist;
    initial_state=traj.initial_state,
    kwargs...
)</code></pre><p>propagates <code>initial_state</code> under the dynamics described by <code>traj.generator</code>. It takes the same keyword arguments as <a href="#QuantumPropagators.propagate-Tuple{Any, Any, Any}"><code>QuantumPropagators.propagate</code></a>, with default values from any property of <code>traj</code> with a <code>prop_</code> prefix (<code>prop_method</code>, <code>prop_inplace</code>, <code>prop_callback</code>, …). See <a href="#QuantumControlBase.init_prop_trajectory-Tuple{Trajectory, Any}"><code>init_prop_trajectory</code></a> for details.</p><p>Note that <code>method</code> (a mandatory keyword argument in <a href="#QuantumPropagators.propagate-Tuple{Any, Any, Any}"><code>QuantumPropagators.propagate</code></a>) must be specified, either as a property <code>prop_method</code> of the trajectory, or by passing a <code>method</code> keyword argument explicitly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/v0.10.0+dev/src/propagate.jl#L9-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControlBase.set_atexit_save_optimization-Tuple{Any, Any}" href="#QuantumControlBase.set_atexit_save_optimization-Tuple{Any, Any}"><code>QuantumControlBase.set_atexit_save_optimization</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Register a callback to dump a running optimization to disk on unexpected exit.</p><p>A long-running optimization routine may use</p><pre><code class="language-julia hljs">if !isnothing(atexit_filename)
    set_atexit_save_optimization(
        atexit_filename, result; msg_property=:message, msg=&quot;Abort: ATEXIT&quot;
    )
    # ...
    popfirst!(Base.atexit_hooks)  # remove callback
end</code></pre><p>to register a callback that writes the given <code>result</code> object to the given <code>filename</code> in JLD2 format in the event that the program terminates unexpectedly. The idea is to avoid data loss if the user presses <code>CTRL-C</code> in a non-interactive program (<code>SIGINT</code>), or if the process receives a <code>SIGTERM</code> from an HPC scheduler because the process has reached its allocated runtime limit. Note that the callback cannot protect against data loss in all possible scenarios, e.g., a <code>SIGKILL</code> will terminate the program without giving the callback a chance to run (as will yanking the power cord).</p><p>As in the above example, the optimization routine should make <code>set_atexit_save_optimization</code> conditional on an <code>atexit_filename</code> keyword argument, which is what <code>QuantumControl.@optimize_or_load</code> will pass to the optimization routine. The optimization routine must remove the callback from <code>Base.atexit_hooks</code> when it exits normally. Note that in an interactive context, <code>CTRL-C</code> will throw an <code>InterruptException</code>, but not cause a shutdown. Optimization routines that want to prevent data loss in this situation should handle the <code>InterruptException</code> and return <code>result</code>, in addition to using <code>set_atexit_save_optimization</code>.</p><p>If <code>msg_property</code> is not <code>nothing</code>, the given <code>msg</code> string will be stored in the corresponding property of the (mutable) <code>result</code> object before it is written out.</p><p>The resulting JLD2 file is compatible with <code>QuantumControl.load_optimization</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/v0.10.0+dev/src/atexit.jl#L3-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControlBase.taus!-Tuple{Vector{ComplexF64}, Any, Any}" href="#QuantumControlBase.taus!-Tuple{Vector{ComplexF64}, Any, Any}"><code>QuantumControlBase.taus!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Overlaps of target states with propagates states, calculated in-place.</p><pre><code class="language-julia hljs">taus!(τ, Ψ, trajectories; ignore_missing_target_state=false)</code></pre><p>overwrites the complex vector <code>τ</code> with the results of <a href="#QuantumControlBase.taus-Tuple{Any, Any}"><code>taus(Ψ, trajectories)</code></a>.</p><p>Throws an <code>ArgumentError</code> if any of trajectories have a <code>target_state</code> of <code>nothing</code>. If <code>ignore_missing_target_state=true</code>, values in <code>τ</code> instead will remain unchanged for any trajectories with a missing target state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/v0.10.0+dev/src/functionals.jl#L41-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControlBase.taus-Tuple{Any, Any}" href="#QuantumControlBase.taus-Tuple{Any, Any}"><code>QuantumControlBase.taus</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Overlaps of target states with propagates states</p><pre><code class="language-julia hljs">τ = taus(Ψ, trajectories)</code></pre><p>calculates a vector of values <span>$τ_k = ⟨Ψ_k^{tgt}|Ψ_k⟩$</span> where <span>$|Ψ_k^{tgt}⟩$</span> is the <code>traj.target_state</code> of the <span>$k$</span>&#39;th element of <code>trajectories</code> and <span>$|Ψₖ⟩$</span> is the <span>$k$</span>&#39;th element of <code>Ψ</code>.</p><p>The definition of the τ values with <span>$Ψ_k^{tgt}$</span> on the left (overlap of target states with propagated states, as opposed to overlap of propagated states with target states) matches Refs. [<a href="../references/#PalaoPRA2003">4</a>] and [<a href="../references/#GoerzQ2022">7</a>].</p><p>The function requires that each trajectory defines a target state. See also <a href="#QuantumControlBase.taus!-Tuple{Vector{ComplexF64}, Any, Any}"><code>taus!</code></a> for an in-place version that includes well-defined error handling for any trajectories whose <code>target_state</code> property is <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/v0.10.0+dev/src/functionals.jl#L14-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Controls.get_controls-Tuple{ControlProblem}" href="#QuantumPropagators.Controls.get_controls-Tuple{ControlProblem}"><code>QuantumPropagators.Controls.get_controls</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">controls = get_controls(problem)</code></pre><p>extracts the controls from <code>problem.trajectories</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/v0.10.0+dev/src/control_problem.jl#L85-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Controls.get_controls-Tuple{Vector{&lt;:Trajectory}}" href="#QuantumPropagators.Controls.get_controls-Tuple{Vector{&lt;:Trajectory}}"><code>QuantumPropagators.Controls.get_controls</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">controls = get_controls(trajectories)</code></pre><p>extracts the controls from a list of <a href="#QuantumControlBase.Trajectory">trajectories</a> (i.e., from each trajectory&#39;s <code>generator</code>). Controls that occur multiple times in the different trajectories will occur only once in the result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/v0.10.0+dev/src/trajectories.jl#L262-L270">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Controls.get_parameters-Tuple{ControlProblem}" href="#QuantumPropagators.Controls.get_parameters-Tuple{ControlProblem}"><code>QuantumPropagators.Controls.get_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parameters = get_parameters(problem)</code></pre><p>extracts the <code>parameters</code> from <code>problem.trajectories</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/v0.10.0+dev/src/control_problem.jl#L95-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Controls.get_parameters-Tuple{Vector{&lt;:Trajectory}}" href="#QuantumPropagators.Controls.get_parameters-Tuple{Vector{&lt;:Trajectory}}"><code>QuantumPropagators.Controls.get_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parameters = get_parameters(trajectories)</code></pre><p>collects and combines get parameter arrays from all the generators in <a href="#QuantumControlBase.Trajectory"><code>trajectories</code></a>. Note that this allows any custom generator type to define a custom <code>get_parameters</code> method to override the default of obtaining the parameters recursively from the controls inside the generator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/v0.10.0+dev/src/trajectories.jl#L287-L296">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Controls.substitute-Tuple{ControlProblem, Any}" href="#QuantumPropagators.Controls.substitute-Tuple{ControlProblem, Any}"><code>QuantumPropagators.Controls.substitute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">problem = substitute(problem::ControlProblem, replacements)</code></pre><p>substitutes in <code>problem.trajectories</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/v0.10.0+dev/src/control_problem.jl#L105-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Controls.substitute-Tuple{Trajectory, Any}" href="#QuantumPropagators.Controls.substitute-Tuple{Trajectory, Any}"><code>QuantumPropagators.Controls.substitute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trajectory = substitute(trajectory::Trajectory, replacements)
trajectories = substitute(trajectories::Vector{&lt;:Trajectory}, replacements)</code></pre><p>recursively substitutes the <code>initial_state</code>, <code>generator</code>, and <code>target_state</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/v0.10.0+dev/src/trajectories.jl#L182-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControlBase.@threadsif-Tuple{Any, Any}" href="#QuantumControlBase.@threadsif-Tuple{Any, Any}"><code>QuantumControlBase.@threadsif</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Conditionally apply multi-threading to <code>for</code> loops.</p><p>This is a variation on <code>Base.Threads.@threads</code> that adds a run-time boolean flag to enable or disable threading. It is intended for <em>internal use</em> in packages building on <code>QuantumControlBase</code>.</p><p>Usage:</p><pre><code class="language-julia hljs">using QuantumControlBase: @threadsif

function optimize(trajectories; use_threads=true)
    @threadsif use_threads for k = 1:length(trajectories)
    # ...
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/v0.10.0+dev/src/conditionalthreads.jl#L7-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.AbstractPropagator" href="#QuantumPropagators.AbstractPropagator"><code>QuantumPropagators.AbstractPropagator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract base type for all <code>Propagator</code> objects.</p><p>All <code>Propagator</code> objects must be instantiated via <a href="#QuantumPropagators.init_prop-Tuple{Any, Any, Any, Val{:Cheby}}"><code>init_prop</code></a> and implement the following interface.</p><p><strong>Properties</strong></p><ul><li><code>state</code> (read-only): The current quantum state in the propagation</li><li><code>tlist</code> (read-only): The time grid for the propagation</li><li><code>t</code> (read-only): The time at which <code>state</code> is defined. An element of <code>tlist</code>.</li><li><code>parameters</code>: parameters that determine the dynamics. The structure of the parameters depends on the concrete <code>Propagator</code> type (i.e., the propagation method). Mutating the <code>parameters</code> affects subsequent propagation steps.</li><li><code>backward</code>: Boolean flag to indicate whether the propagation moves forward or backward in time</li><li><code>inplace</code>: Boolean flag to indicate whether <code>propagator.state</code> is modified in-place or is recreated by every call of <code>prop_step!</code> or <code>set_state!</code>. With <code>inplace=false</code>, the propagator should generally avoid in-place operations, such as calls to <a href="#QuantumPropagators.Controls.evaluate!-Tuple{Any, Tuple, Vararg{Any}}"><code>QuantumPropagators.Controls.evaluate!</code></a>.</li></ul><p>Concrete <code>Propagator</code> types may have additional properties or fields, but these should be considered private.</p><p><strong>Methods</strong></p><ul><li><a href="#QuantumPropagators.reinit_prop!-Tuple{Any, Any}"><code>reinit_prop!</code></a> — reset the propagator to a new initial state at the beginning of the time grid (or the end, for backward propagation)</li><li><a href="#QuantumPropagators.prop_step!"><code>prop_step!</code></a> – advance the propagator by one step forward (or backward) on the time grid.</li><li><a href="#QuantumPropagators.set_state!-Tuple{QuantumPropagators.AbstractPropagator, Any}"><code>set_state!</code></a> — safely mutate the current quantum <code>state</code> of the propagation. Note that directly mutating the <code>state</code> property is not safe. However, <code>Ψ = propagator.state; foo_mutate!(Ψ), set_state!(propagator, Ψ)</code> for some mutating function <code>foo_mutate!</code> is guaranteed to be safe and efficient for both in-place and not-in-place propagators.</li><li><a href="#QuantumPropagators.set_t!-Tuple{Any, Any}"><code>set_t!</code></a> — safely mutate the current time (<code>propagator.t</code>), snapping to the values of <code>tlist</code>.</li></ul><p><strong>See also</strong></p><ul><li><a href="#QuantumPropagators.PiecewisePropagator"><code>PiecewisePropagator</code></a> — specialization of <code>AbstractPropagator</code> for piecewise propagation methods.</li><li><a href="#QuantumPropagators.PWCPropagator"><code>PWCPropagator</code></a> — specialization of <a href="#QuantumPropagators.PiecewisePropagator"><code>PiecewisePropagator</code></a> for piecewise-constant propagation methods.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/propagator.jl#L4-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.ChebyPropagator" href="#QuantumPropagators.ChebyPropagator"><code>QuantumPropagators.ChebyPropagator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Propagator for Chebychev propagation (<code>method=QuantumPropagators.Cheby</code>).</p><p>This is a <a href="#QuantumPropagators.PWCPropagator"><code>PWCPropagator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/cheby_propagator.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.ExpPropagator" href="#QuantumPropagators.ExpPropagator"><code>QuantumPropagators.ExpPropagator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Propagator for propagation via direct exponentiation (<code>method=QuantumPropagators.ExpProp</code>)</p><p>This is a <a href="#QuantumPropagators.PWCPropagator"><code>PWCPropagator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/exp_propagator.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.NewtonPropagator" href="#QuantumPropagators.NewtonPropagator"><code>QuantumPropagators.NewtonPropagator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Propagator for Newton propagation (<code>method=QuantumPropagators.Newton</code>).</p><p>This is a <a href="#QuantumPropagators.PWCPropagator"><code>PWCPropagator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/newton_propagator.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.PWCPropagator" href="#QuantumPropagators.PWCPropagator"><code>QuantumPropagators.PWCPropagator</code></a> — <span class="docstring-category">Type</span></header><section><div><p><a href="#QuantumPropagators.PiecewisePropagator"><code>PiecewisePropagator</code></a> sub-type for piecewise-constant propagators.</p><p>Like the more general <a href="#QuantumPropagators.PiecewisePropagator"><code>PiecewisePropagator</code></a>, this is characterized by <code>propagator.parameters</code> mapping the controls in the <code>generator</code> to a vector of amplitude value on the midpoints of the time grid intervals.</p><p>The propagation will use these values as constant within each interval.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/propagator.jl#L66-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.PiecewisePropagator" href="#QuantumPropagators.PiecewisePropagator"><code>QuantumPropagators.PiecewisePropagator</code></a> — <span class="docstring-category">Type</span></header><section><div><p><a href="#QuantumPropagators.AbstractPropagator"><code>AbstractPropagator</code></a> sub-type for piecewise propagators.</p><p>A piecewise propagator is determined by a single parameter per control and time grid interval. Consequently, the <code>propagator.parameters</code> are a dictionary mapping the controls found in the <code>generator</code> via <a href="#QuantumPropagators.Controls.get_controls-Tuple{ControlProblem}"><code>get_controls</code></a> to a vector of values defined on the intervals of the time grid, see <a href="#QuantumPropagators.Controls.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>discretize_on_midpoints</code></a>. This does not necessarily imply that these values are the piecewise-constant amplitudes for the intervals. A general piecewise propagator might use interpolation to obtain actual amplitudes within any given time interval.</p><p>When the amplitudes <em>are</em> piecewise-constant, the propagator should be a concrete instantiation of a <a href="#QuantumPropagators.PWCPropagator"><code>PWCPropagator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/propagator.jl#L50-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Propagation" href="#QuantumPropagators.Propagation"><code>QuantumPropagators.Propagation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Wrapper around the parameters of a call to <a href="#QuantumPropagators.propagate-Tuple{Any, Any, Any}"><code>propagate</code></a>.</p><pre><code class="language-julia hljs">Propagation(
    generator, tlist;
    pre_propagation=nothing, post_propagation=nothing,
    kwargs...
)

Propagation(
    propagator;
    pre_propagation=nothing, post_propagation=nothing,
    kwargs...
)</code></pre><p>is a wrapper around the arguments for <a href="#QuantumPropagators.propagate-Tuple{Any, Any, Any}"><code>propagate</code></a> / <a href="#QuantumPropagators.init_prop-Tuple{Any, Any, Any, Val{:Cheby}}"><code>init_prop</code></a>, for use within <a href="#QuantumPropagators.propagate_sequence-Tuple{Any, Vector{Propagation}}"><code>propagate_sequence</code></a>.</p><p>The positional and keyword arguments are those accepted by the above propagation routines, excluding the initial state. A <code>Propagation</code> may in addition include the <code>pre_propagation</code> and <code>post_propagation</code> keyword arguments recognized by <a href="#QuantumPropagators.propagate_sequence-Tuple{Any, Vector{Propagation}}"><code>propagate_sequence</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/propagate_sequence.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.cheby_get_spectral_envelope-NTuple{4, Any}" href="#QuantumPropagators.cheby_get_spectral_envelope-NTuple{4, Any}"><code>QuantumPropagators.cheby_get_spectral_envelope</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Determine the spectral envelope of a <code>generator</code>.</p><pre><code class="language-julia hljs">E_min, E_max = cheby_get_spectral_envelope(
    generator, tlist, control_ranges, method; kwargs...
)</code></pre><p>estimates a lower bound <code>E_min</code> the lowest eigenvalue of the generator for any values of the controls specified by <code>control_ranges</code>, and an upper bound <code>E_max</code> for the highest eigenvalue.</p><p>This is done by constructing operators from the extremal values for the controls as specified in <code>control_ranges</code> and taking the smallest/largest return values from <a href="#QuantumPropagators.SpectralRange.specrange-Tuple{Any, Val{:arnoldi}}"><code>specrange</code></a> for those operators.</p><p><strong>Arguments</strong></p><ul><li><code>generator</code>: dynamical generator, e.g. a time-dependent</li><li><code>tlist</code>: The time grid for the propagation</li><li><code>control_ranges</code>: a dict that maps controls that occur in <code>generator</code> (cf. <a href="#QuantumPropagators.Controls.get_controls-Tuple{ControlProblem}"><code>get_controls</code></a> to a tuple of minimum and maximum amplitude for that control</li><li><code>method</code>: method name to pass to  <a href="#QuantumPropagators.SpectralRange.specrange-Tuple{Any, Val{:arnoldi}}"><code>specrange</code></a></li><li><code>kwargs</code>: Any remaining keyword arguments are passed to <a href="#QuantumPropagators.SpectralRange.specrange-Tuple{Any, Val{:arnoldi}}"><code>specrange</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/cheby_propagator.jl#L302-L331">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.disable_timings-Tuple{}" href="#QuantumPropagators.disable_timings-Tuple{}"><code>QuantumPropagators.disable_timings</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Disable the collection of <code>TimerOutputs</code> data.</p><pre><code class="language-julia hljs">QuantumPropagators.disable_timings()</code></pre><p>disables the collection of timing data previously enabled with <a href="#QuantumPropagators.enable_timings-Tuple{}"><code>enable_timings</code></a>. This triggers recompilation to completely remove profiling from the code. That is, there is <a href="https://github.com/KristofferC/TimerOutputs.jl#overhead">zero cost</a> when the collection of timing data is disabled.</p><p>Returns <a href="#QuantumPropagators.timings_enabled-Tuple{}"><code>QuantumPropagators.timings_enabled()</code></a>, i.e., <code>false</code> if successful.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/timings.jl#L65-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.enable_timings-Tuple{}" href="#QuantumPropagators.enable_timings-Tuple{}"><code>QuantumPropagators.enable_timings</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Enable the collection of <code>TimerOutputs</code> data.</p><pre><code class="language-julia hljs">QuantumPropagators.enable_timings()</code></pre><p>enables certain portions of the package to collect <a href="https://github.com/KristofferC/TimerOutputs.jl"><code>TimerOutputs</code></a> internally. This aids in profiling and benchmarking propagation methods.</p><p>Specifically, after <code>enable_timings()</code>, for any <a href="#QuantumPropagators.ChebyPropagator"><code>ChebyPropagator</code></a> or <a href="#QuantumPropagators.NewtonPropagator"><code>NewtonPropagator</code></a>, timing data will become available in <code>propagator.wrk.timing_data</code> (as a <a href="https://github.com/KristofferC/TimerOutputs.jl#usage"><code>TimerOutput</code></a> instance). This data is reset when the propagator is re-instantiated with <a href="#QuantumPropagators.init_prop-Tuple{Any, Any, Any, Val{:Cheby}}"><code>init_prop</code></a> or re-initialized with <a href="#QuantumPropagators.reinit_prop!-Tuple{Any, Any}"><code>reinit_prop!</code></a>. This makes the data local to any call of <a href="#QuantumPropagators.propagate-Tuple{Any, Any, Any}"><code>propagate</code></a>.</p><p>Note that <code>enable_timings()</code> triggers recompilation, so <a href="#QuantumPropagators.propagate-Tuple{Any, Any, Any}"><code>propagate</code></a> should be called at least twice to avoid compilation overhead in the timing data. There is still a <a href="https://github.com/KristofferC/TimerOutputs.jl#overhead">small overhead</a> for collecting the timing data.</p><p>The collection of timing data can be disabled again with <a href="#QuantumPropagators.disable_timings-Tuple{}"><code>disable_timings</code></a>.</p><p>Returns <a href="#QuantumPropagators.timings_enabled-Tuple{}"><code>QuantumPropagators.timings_enabled()</code></a>, i.e., <code>true</code> if successful.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/timings.jl#L3-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.init_prop-Tuple{Any, Any, Any, Val{:Cheby}}" href="#QuantumPropagators.init_prop-Tuple{Any, Any, Any, Val{:Cheby}}"><code>QuantumPropagators.init_prop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">using QuantumPropagators: Cheby

cheby_propagator = init_prop(
    state,
    generator,
    tlist;
    method=Cheby,
    inplace=QuantumPropagators.Interfaces.supports_inplace(state),
    backward=false,
    verbose=false,
    parameters=nothing,
    control_ranges=nothing,
    specrange_method=:auto,
    specrange_buffer=0.01,
    cheby_coeffs_limit=1e-12,
    check_normalization=false,
    specrange_kwargs...
)</code></pre><p>initializes a <a href="#QuantumPropagators.ChebyPropagator"><code>ChebyPropagator</code></a>.</p><p><strong>Method-specific keyword arguments</strong></p><ul><li><code>control_ranges</code>: a dict the maps the controls in <code>generator</code> (see <a href="#QuantumPropagators.Controls.get_controls-Tuple{ControlProblem}"><code>get_controls</code></a>) to a tuple of min/max values. The Chebychev coefficients will be calculated based on a spectral envelope that assumes that each control can take arbitrary values within the min/max range. If not given, the ranges are determined automatically. Specifying manual control ranges can be useful when the the control amplitudes (<code>parameters</code>) may change during the propagation, e.g. in a sequential-update control scheme.</li><li><code>specrange_method</code>: Method to pass to the <a href="#QuantumPropagators.SpectralRange.specrange-Tuple{Any, Val{:arnoldi}}"><code>specrange</code></a> function</li><li><code>specrange_buffer</code>: An additional factor by which to enlarge the estimated  spectral range returned by <a href="#QuantumPropagators.SpectralRange.specrange-Tuple{Any, Val{:arnoldi}}"><code>specrange</code></a>, in order to ensure that Chebychev coefficients are based on an overestimation of the spectral range.</li><li><code>cheby_coeffs_limit</code>: The maximum magnitude of Chebychev coefficients that should be treated as non-zero</li><li><code>check_normalization</code>: Check whether the Hamiltonian has been properly normalized, i.e., that the spectral range of <code>generator</code> has not been underestimated. This slowes down the propagation, but is advisable for novel <code>generators</code>.</li><li><code>uniform_dt_tolerance=1e-12</code>: How much the intervals of <code>tlist</code> are allowed to vary while still being considered constant.</li><li><code>specrange_kwargs</code>: All further keyword arguments are passed to the <a href="#QuantumPropagators.SpectralRange.specrange-Tuple{Any, Val{:arnoldi}}"><code>specrange</code></a> function. Most notably, with the default <code>specrange_method=:auto</code> (or <code>specrange_method=:manual</code>), passing <code>E_min</code> and <code>E_max</code> allows to manually specify the spectral range of <code>generator</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/cheby_propagator.jl#L33-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.init_prop-Tuple{Any, Any, Any, Val{:ExpProp}}" href="#QuantumPropagators.init_prop-Tuple{Any, Any, Any, Val{:ExpProp}}"><code>QuantumPropagators.init_prop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">using QuantumPropagators: ExpProp

exp_propagator = init_prop(
    state,
    generator,
    tlist;
    method=ExpProp,
    inplace=QuantumPropagators.Interfaces.supports_inplace(state),
    backward=false,
    verbose=false,
    parameters=nothing,
    func=(H_dt -&gt; exp(-1im * H_dt))
    convert_state=_exp_prop_convert_state(state),
    convert_operator=_exp_prop_convert_operator(generator),
    _...
)</code></pre><p>initializes an <a href="#QuantumPropagators.ExpPropagator"><code>ExpPropagator</code></a>.</p><p><strong>Method-specific keyword arguments</strong></p><ul><li><code>func</code>: The function to evaluate. The argument <code>H_dt</code> is obtained by constructing an operator <code>H</code> from <code>generator</code> via the <a href="#QuantumPropagators.Controls.evaluate-Tuple{Any, Vararg{Any}}"><code>evaluate</code></a> function and the multiplied with the time step <code>dt</code> for the current time interval. The propagation then simply multiplies the return value of <code>func</code> with the current state</li><li><code>convert_state</code>:  Type to which to temporarily convert states before multiplying the return value of <code>func</code>.</li><li><code>convert_operator</code>: Type to which to convert the operator <code>H</code> before multiplying it with <code>dt</code> and plugging the result into <code>func</code></li></ul><p>The <code>convert_state</code> and <code>convert_operator</code> parameters are useful for when the <code>generator</code> and or <code>state</code> are unusual data structures for which the relevant methods to calculate <code>func</code> are not defined. Often, it is easier to temporarily convert them to standard complex matrices and vectors than to implement the missing methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/exp_propagator.jl#L41-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.init_prop-Tuple{Any, Any, Any, Val{:Newton}}" href="#QuantumPropagators.init_prop-Tuple{Any, Any, Any, Val{:Newton}}"><code>QuantumPropagators.init_prop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">using QuantumPropagators: Newton

newton_propagator = init_prop(
    state,
    generator,
    tlist;
    method=Newton,
    inplace=QuantumPropagators.Interfaces.supports_inplace(state),
    backward=false,
    verbose=false,
    parameters=nothing,
    m_max=10,
    func=(z -&gt; exp(-1im * z)),
    norm_min=1e-14,
    relerr=1e-12,
    max_restarts=50,
    _...
)</code></pre><p>initializes a <a href="#QuantumPropagators.NewtonPropagator"><code>NewtonPropagator</code></a>.</p><p><strong>Method-specific keyword arguments</strong></p><ul><li><code>m_max</code>: maximum Krylov dimension, cf. <a href="#QuantumPropagators.Newton.NewtonWrk"><code>NewtonWrk</code></a></li><li><code>func</code>, <code>norm_min</code>, <code>relerr</code>, <code>max_restarts</code>: parameter to pass to <a href="#QuantumPropagators.Newton.newton!-NTuple{4, Any}"><code>newton!</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/newton_propagator.jl#L31-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.init_prop-Tuple{Any, Any, Any}" href="#QuantumPropagators.init_prop-Tuple{Any, Any, Any}"><code>QuantumPropagators.init_prop</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Initialize a <code>Propagator</code>.</p><pre><code class="language-julia hljs">propagator = init_prop(
    state, generator, tlist;
    method,  # mandatory keyword argument
    backward=false,
    inplace=QuantumPropagators.Interfaces.supports_inplace(state),
    piecewise=nothing,
    pwc=nothing,
    kwargs...
)</code></pre><p>initializes a propagator for the time propagation of the given <code>state</code> over a time grid <code>tlist</code> under the time-dependent generator (Hamiltonian/Liouvillian) <code>generator</code>.</p><p><strong>Arguments</strong></p><ul><li><code>state</code>: The &quot;initial&quot; state for the propagation. For <code>backward=false</code>, this state is taken to be at initial time (<code>tlist[begin]</code>); and for <code>backward=true</code>, at the final time (<code>tlist[end]</code>)</li><li><code>generator</code>: The time-dependent generator of the dynamics</li><li><code>tlist</code>: The time grid over which which the propagation is defined. This may or may not be equidistant.</li></ul><p><strong>Mandatory keyword arguments</strong></p><ul><li><code>method</code>: The propagation method to use. May be given as a name (<code>Symbol</code>), but the recommended usage is to pass a module implementing the propagation method, e.g., <code>using QuantumPropagators: Cheby; method = Cheby</code>. Passing a module ensures that the code implementing the method is correctly loaded. This is particularly important for propagators using third-party backends, like with <code>method=OrdinaryDiffEq</code>.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>backward</code>: If <code>true</code>, initialize the propagator for a backward propagation. The resulting <code>propagator.t</code> will be <code>tlist[end]</code>, and subsequent calls to <a href="#QuantumPropagators.prop_step!"><code>prop_step!</code></a> will move backward on <code>tlist</code>.</li><li><code>inplace</code>: If <code>true</code>, the <code>state</code> property of the resulting propagator will be changed in-place by any call to <a href="#QuantumPropagators.prop_step!"><code>prop_step!</code></a>. If <code>false</code>, each call to <a href="#QuantumPropagators.prop_step!"><code>prop_step!</code></a> changes the reference for <code>propagator.state</code>, and the propagation will not use any in-place operations. Not all propagation methods may support both in-place and not-in-place propagation. In-place propagation is generally more efficient for larger Hilbert space dimensions, but may not be compatible, e.g., with automatic differentiation.</li><li><code>piecewise</code>: If given as a boolean, <code>true</code> enforces that the resulting propagator is a <a href="#QuantumPropagators.PiecewisePropagator"><code>PiecewisePropagator</code></a>, and <code>false</code> enforces that it not a <a href="#QuantumPropagators.PiecewisePropagator"><code>PiecewisePropagator</code></a>. For the default <code>piecewise=nothing</code>, whatever type of propagation is the default for the given <code>method</code> will be used. Throw an error if the given <code>method</code> does not support the required type of propagation.</li><li><code>pwc</code>: Like <code>piecewise</code>, but for the stronger <a href="#QuantumPropagators.PWCPropagator"><code>PWCPropagator</code></a>.</li></ul><p>All other <code>kwargs</code> are method-dependent and are ignored for methods that do not support them.</p><p>The type of the returned <code>propagator</code> is a sub-type of <a href="#QuantumPropagators.AbstractPropagator"><code>AbstractPropagator</code></a>, respectively a sub-type of <a href="#QuantumPropagators.PiecewisePropagator"><code>PiecewisePropagator</code></a> if <code>piecewise=true</code> or a sub-type of <a href="#QuantumPropagators.PWCPropagator"><code>PWCPropagator</code></a> if <code>pwc=true</code>.</p><p><strong>Internals</strong></p><p>Internally, the (mandatory) keyword <code>method</code> is converted into a fourth positional argument. This allows propagation methods to define their own implementation of <code>init_prop</code> via multiple dispatch. However, when <em>calling</em> <code>init_prop</code> in high-level code, <code>method</code> must always be given as a keyword argument.</p><p><strong>See also</strong></p><ul><li><a href="#QuantumPropagators.reinit_prop!-Tuple{Any, Any}"><code>reinit_prop!</code></a> — Re-initialize a propagator</li><li><a href="#QuantumPropagators.propagate-Tuple{Any, Any, Any}"><code>propagate</code></a> — Higher-level propagation interface</li><li><a href="#QuantumPropagators.Interfaces.check_propagator-Tuple{Any}">`check_propagator</a> — a function to verify the interface described above.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/propagator.jl#L129-L208">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.ode_function-Union{Tuple{GT}, Tuple{GT, Any}} where GT" href="#QuantumPropagators.ode_function-Union{Tuple{GT}, Tuple{GT, Any}} where GT"><code>QuantumPropagators.ode_function</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Wrap around a <a href="#QuantumPropagators.Generators.Generator"><code>Generator</code></a>, for use as an ODE function.</p><pre><code class="language-julia hljs">f = ode_function(generator, tlist; c=-1im)</code></pre><p>creates a function suitable to be passed to <a href="https://docs.sciml.ai/DiffEqDocs/stable/types/ode_types/#SciMLBase.ODEProblem"><code>ODEProblem</code></a>.</p><p class="math-container">\[\gdef\op#1{\hat{#1}}
\gdef\ket#1{\vert{#1}\rangle}\]</p><p>With <code>generator</code> corresponding to <span>$\op{H}(t)$</span>, this implicitly encodes the ODE</p><p class="math-container">\[\frac{\partial}{\partial t} \ket{\Psi(t)} = c \op{H}(t) \ket{\Psi(t)}\]</p><p>for the state <span>$\ket{\Psi(t)}$</span>. With the default <span>$c = -i$</span>, this corresponds to the Schrödinger equation, or the Liouville equation with <a href="#QuantumPropagators.Generators.liouvillian"><code>convention=:LvN</code></a>.</p><p>The resulting <code>f</code> works both in-place and not-in-place, as</p><pre><code class="language-julia hljs">f(ϕ, Ψ, vals_dict, t)   # in-place `f(du, u, p, t)`
ϕ = f(Ψ, vals_dict, t)  # not-in-place `f(u, p, t)`</code></pre><p>Calling <code>f</code> as above is functionally equivalent to calling <a href="#QuantumPropagators.Controls.evaluate-Tuple{Any, Vararg{Any}}"><code>evaluate</code></a> to obtain an operator <code>H</code> from the original time-dependent <code>generator</code>, and then applying <code>H</code> to the current quantum state <code>Ψ</code>:</p><pre><code class="language-julia hljs">H = evaluate(f.generator, t; vals_dict=vals_dict)
ϕ = c * H * Ψ</code></pre><p>where <code>vals_dict</code> may be a dictionary mapping controls to values (set as the parameters <code>p</code> of the underlying ODE solver).</p><p>If <a href="#QuantumPropagators.enable_timings-Tuple{}"><code>QuantumPropagators.enable_timings()</code></a> has been called, profiling data is collected in <code>f.timing_data</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/ode_function.jl#L4-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.prop_step!" href="#QuantumPropagators.prop_step!"><code>QuantumPropagators.prop_step!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Advance the <code>propagator</code> by a single time step.</p><pre><code class="language-julia hljs">state = prop_step!(propagator)</code></pre><p>returns the state obtained from propagating to the next point on the time grid from <code>propagator.t</code>, respectively the previous point if <code>propagator.backward</code> is true.</p><p>When the propagation would lead out of the time grid, <code>prop_step!</code> leaves <code>propagator</code> unchanged and returns <code>nothing</code>. Thus, a return value of <code>nothing</code> may be used to signal that a propagation has completed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/propagator.jl#L315-L329">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.propagate-Tuple{Any, Any, Any}" href="#QuantumPropagators.propagate-Tuple{Any, Any, Any}"><code>QuantumPropagators.propagate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Propagate a state over an entire time grid.</p><pre><code class="language-julia hljs">state = propagate(
    state,
    generator,
    tlist;
    method,  # mandatory keyword argument
    check=true,
    backward=false,
    inplace=QuantumPropagators.Interfaces.supports_inplace(state),
    verbose=false,
    piecewise=nothing,
    pwc=nothing,
    storage=nothing,
    observables=&lt;store state&gt;,
    callback=nothing,
    show_progress=false,
    init_prop_kwargs...)</code></pre><p>propagates <code>state</code> of the entire time grid and returns the propagated states, or a storage array of data collected during the propagation. This high-level routine performs the following three steps:</p><ol><li><p>If <code>check=true</code> (default), check that <code>state</code>, <code>generator</code>, and <code>tlist</code> are  consistent with the required interface.</p></li><li><p>Initialize a <code>propagator</code> via <a href="#QuantumPropagators.init_prop-Tuple{Any, Any, Any, Val{:Cheby}}"><code>init_prop</code></a>:</p><p><code>init_prop(state, generator, tlist; method, inplace, init_prop_kwargs...)</code></p></li><li><p>Call and return the result of</p><p><code>propagate(propagator; storage, observables, show_progress, callback)</code></p></li></ol><p><strong>Arguments</strong></p><ul><li><code>state</code>: The &quot;initial&quot; state for the propagation. For <code>backward=false</code>, this state is taken to be at initial time (<code>tlist[begin]</code>); and for <code>backward=true</code>, at the final time (<code>tlist[end]</code>)</li><li><code>generator</code>: The time-dependent generator of the dynamics</li><li><code>tlist</code>: The time grid over which which the propagation is defined. This may or may not be equidistant.</li></ul><p><strong>Mandatory keyword arguments</strong></p><ul><li><code>method</code>: The propagation method to use. May be given as a name (<code>Symbol</code>), but the recommended usage is to pass a module implementing the propagation method, cf. <a href="#QuantumPropagators.init_prop-Tuple{Any, Any, Any, Val{:Cheby}}"><code>init_prop</code></a>.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>check</code>: if <code>true</code>, check that <code>state</code>, <code>generator</code>, and <code>tlist</code> pass <a href="#QuantumPropagators.Interfaces.check_state-Tuple{Any}"><code>check_state</code></a>, <a href="#QuantumPropagators.Interfaces.check_generator-Tuple{Any}"><code>check_generator</code></a> and <a href="#QuantumPropagators.Interfaces.check_tlist-Tuple{Any}"><code>check_tlist</code></a>, respectively.</li><li><code>backward</code>: If <code>true</code>, propagate backward in time</li><li><code>inplace</code>: If <code>true</code>, propagate using in-place operations. If <code>false</code>, avoid in-place operations. Not all propagation methods support both in-place and not-in-place propagation. Note that <code>inplace=true</code> requires that <a href="#QuantumPropagators.Interfaces.supports_inplace-Tuple{Vector{ComplexF64}}"><code>QuantumPropagators.Interfaces.supports_inplace</code></a> for <code>state</code> is <code>true</code>.</li><li><code>piecewise</code>: If given as a boolean, ensure that the internal <code>propagator</code> is an instance of <a href="#QuantumPropagators.PiecewisePropagator"><code>PiecewisePropagator</code></a>, cf. <a href="#QuantumPropagators.init_prop-Tuple{Any, Any, Any, Val{:Cheby}}"><code>init_prop</code></a>.</li><li><code>pwc</code>: If given a a boolean, do a piecewise constant propagation where the generator in each interval is constant (the internal <code>propagator</code> is a <a href="#QuantumPropagators.PWCPropagator"><code>PWCPropagator</code></a>, cf. <a href="#QuantumPropagators.init_prop-Tuple{Any, Any, Any, Val{:Cheby}}"><code>init_prop</code></a>)</li><li><code>storage</code>: Flag whether to store and return the propagated states / observables, or pre-allocated storage array. See Notes below.</li><li><code>observables</code>: Converters for data to be stored in <code>storage</code>. See Notes below.</li><li><code>callback</code>: Function to call after each propagation step. See Notes below.</li><li><code>show_progress</code>: Whether to show a progress bar. See Notes below.</li></ul><p>All remaining keyword arguments are passed to <a href="#QuantumPropagators.init_prop-Tuple{Any, Any, Any, Val{:Cheby}}"><code>init_prop</code></a> to initialize the <a href="#QuantumPropagators.AbstractPropagator"><code>Propagator</code></a> that is used internally to drive the optimization. Unknown keyword arguments will be ignored.</p><p><strong>Notes</strong></p><p>In general, there is no requirement that <code>tlist</code> has a constant time step, although some propagation methods (most notably <a href="#QuantumPropagators.Cheby.cheby!-NTuple{4, Any}"><code>Cheby</code></a>) only support a uniform time grid.</p><p>If <code>storage</code> is given as a container pre-allocated via <a href="#QuantumPropagators.Storage.init_storage-Tuple{Any, AbstractVector}"><code>init_storage</code></a>, it will be filled with data determined by the <code>observables</code>. Specifically, after each propagation step,</p><pre><code class="language-julia hljs">data = map_observables(observables, tlist, i, state)
write_to_storage!(storage, i, data)</code></pre><p>is executed, where <code>state</code> is defined at time <code>tlist[i]</code>. See <a href="#QuantumPropagators.Storage.map_observables-NTuple{4, Any}"><code>map_observables</code></a> and <a href="#QuantumPropagators.Storage.write_to_storage!-Tuple{AbstractVector, Integer, Any}"><code>write_to_storage!</code></a> for details. The default values for <code>observables</code> results simply in the propagated states at every point in time being stored.</p><p>The <code>storage</code> parameter may also be given as <code>true</code>, and a new storage array will be created internally with <a href="#QuantumPropagators.Storage.init_storage-Tuple{Any, AbstractVector}"><code>init_storage</code></a> and returned instead of the propagated state:</p><pre><code class="language-julia hljs">data = propagate(
    state, generator, tlist; method,
    backward=false; storage=true, observables=observables,
    callback=nothing, show_progress=false, init_prop_kwargs...)</code></pre><p>If <code>backward</code> is <code>true</code>, the input state is assumed to be at time <code>tlist[end]</code>, and the propagation progresses backward in time (with a negative time step <code>dt</code>). If <code>storage</code> is given, it will be filled back-to-front during the backward propagation.</p><p>If <code>callback</code> is given as a callable, it will be called after each propagation step, as <code>callback(propagator, observables)</code> where <code>propagator</code> is <a href="#QuantumPropagators.AbstractPropagator"><code>Propagator</code></a> object driving the propagation. The <code>callback</code> is called before calculating any observables. Example usage includes writing data to file, or modifying <code>state</code> via <a href="#QuantumPropagators.set_state!-Tuple{QuantumPropagators.AbstractPropagator, Any}"><code>set_state!</code></a>, e.g., removing amplitude from the lowest and highest level to mitigate &quot;truncation error&quot;.</p><p>If <code>show_progress</code> is given as <code>true</code>, a progress bar will be shown for long-running propagation. In order to customize the progress bar, <code>show_progress</code> may also be a function that receives <code>length(tlist)</code> and returns a <code>ProgressMeter.Progress</code> instance.</p><p>If <code>in_place=false</code> is given, the propagation avoids in-place operations. This is slower than <code>inplace=true</code>, but is often required in the context of automatic differentiation (AD), e.g., with <a href="https://fluxml.ai/Zygote.jl/">Zygote</a>. That is, use <code>in_place=false</code> if <code>propagate</code> is called inside a function to be passed to <code>Zygote.gradient</code>, <code>Zygote.pullback</code>, or a similar function. In an AD context, <code>storage</code> and <code>show_progress</code> should not be used.</p><p>The <code>propagate</code> routine returns the propagated state at <code>tlist[end]</code>, respectively <code>tlist[1]</code> if <code>backward=true</code>, or a storage array with the stored states / observable data if <code>storage=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/propagate.jl#L24-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.propagate-Tuple{Any, Any}" href="#QuantumPropagators.propagate-Tuple{Any, Any}"><code>QuantumPropagators.propagate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">state = propagate(
    state,
    propagator;
    storage=nothing,
    observables=&lt;store state&gt;,
    show_progress=false,
    callback=nothing,
    reinit_prop_kwargs...
)</code></pre><p>re-initializes the given <code>propagator</code> with <code>state</code> (see <a href="#QuantumPropagators.reinit_prop!-Tuple{Any, Any}"><code>reinit_prop!</code></a>) and then calls the lower-level <code>propagate(propagator; ...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/propagate.jl#L238-L253">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.propagate-Tuple{Any}" href="#QuantumPropagators.propagate-Tuple{Any}"><code>QuantumPropagators.propagate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">state = propagate(
    propagator;
    storage=nothing,
    observables=&lt;store state&gt;,
    show_progress=false,
    callback=nothing,
)</code></pre><p>propagates a freshly initialized <code>propagator</code> (immediately after <a href="#QuantumPropagators.init_prop-Tuple{Any, Any, Any, Val{:Cheby}}"><code>init_prop</code></a>). Used in the higher-level <a href="#QuantumPropagators.propagate-Tuple{Any, Any, Any}"><code>propagate(state, generator, tlist; kwargs...)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/propagate.jl#L268-L282">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.propagate_sequence-Tuple{Any, Vector{Propagation}}" href="#QuantumPropagators.propagate_sequence-Tuple{Any, Vector{Propagation}}"><code>QuantumPropagators.propagate_sequence</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Propagate a state through a sequence of generators.</p><pre><code class="nohighlight hljs">states = propagate_sequence(
    state,
    propagations;
    storage=nothing,
    pre_propagation=nothing,
    post_propagation=nothing,
    kwargs...
)</code></pre><p>takes an <code>initial</code> state and performs a sequence of <a href="#QuantumPropagators.propagate-Tuple{Any, Any, Any}"><code>propagate</code></a> calls using the parameters in <code>propagations</code>. The initial state for each step in the sequence is the state resulting from the previous step. Optionally, before and after each step, a <code>pre_propagation</code> and <code>post_propagation</code> function may modify the state instantaneously, e.g., to perform a frame transformation. Return the vector of states at the end of each step (after any <code>post_propagation</code>, before any next <code>pre_propagation</code> of the next step).</p><p><strong>Arguments</strong></p><ul><li><code>state</code>: The initial state</li><li><code>propagations</code>: A vector of <a href="#QuantumPropagators.Propagation"><code>Propagation</code></a> instances, one per step in the sequence, each containing the arguments for the call to <a href="#QuantumPropagators.propagate-Tuple{Any, Any, Any}"><code>propagate</code></a> for that step. The <a href="#QuantumPropagators.Propagation"><code>Propagation</code></a> contains the generator and time grid for each step as positional parameters, or alternatively a pre-initialized <a href="#QuantumPropagators.AbstractPropagator"><code>Propagator</code></a>, and any keyword arguments for <a href="#QuantumPropagators.propagate-Tuple{Any, Any, Any}"><code>propagate</code></a> that are specific to that step. Note that <a href="#QuantumPropagators.propagate-Tuple{Any, Any, Any}"><code>propagate</code></a> keyword arguments that are common to all steps can be given directly to <code>propagate_sequence</code>.</li><li><code>storage</code>: If <code>storage=true</code>, return a vector of storage objects as returned by <code>propagate(…, storage=true)</code> for each propagation step, instead of the state after each step. To use a pre-initialized <code>storage</code>, each <a href="#QuantumPropagators.Propagation"><code>Propagation</code></a> in <code>propagations</code> should have a <code>storage</code> keyword argument instead.</li><li><code>pre_propagation</code>: If not <code>nothing</code>, must be a function that receives the same arguments as <a href="#QuantumPropagators.propagate-Tuple{Any, Any, Any}"><code>propagate</code></a> and returns a state. Called immediately before the <a href="#QuantumPropagators.propagate-Tuple{Any, Any, Any}"><code>propagate</code></a> of each step, and the state returned by <code>pre_propagation</code> will become the initial state for the subsequent call to <a href="#QuantumPropagators.propagate-Tuple{Any, Any, Any}"><code>propagate</code></a>. Generally, <code>pre_propagation</code> would be different in each step of the sequence, and should be given as a keyword argument in a particular <a href="#QuantumPropagators.Propagation"><code>Propagation</code></a>.</li><li><code>post_propagation</code>: If not <code>nothing</code>, a function that receives the same arguments as <a href="#QuantumPropagators.propagate-Tuple{Any, Any, Any}"><code>propagate</code></a> and returns a state, see <code>pre_propagation</code>. The returned state becomes the initial state for the next step in the sequence (and may be further processed by the following <code>pre_propagation</code>). Like <code>pre_propagation</code>, this will generally be set as a keyword argument for a particular <a href="#QuantumPropagators.Propagation"><code>Propagation</code></a>, not as a global keyword argument to <code>propagate_sequence</code>.</li></ul><p>All other keyword arguments are forwarded to <code>propagate</code>. Thus, keyword arguments that are common to all steps in the sequence should be given as keyword arguments to <code>propagate_sequence</code> directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/propagate_sequence.jl#L34-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.reinit_prop!-Tuple{Any, Any}" href="#QuantumPropagators.reinit_prop!-Tuple{Any, Any}"><code>QuantumPropagators.reinit_prop!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Re-initialize a propagator.</p><pre><code class="language-julia hljs">reinit_prop!(propagator, state; kwargs...)</code></pre><p>resets the <code>propagator</code> to <code>state</code> at the beginning of the time grid, respectively the end of the time grid if <code>propagator.backward</code> is true.</p><p>At a minimum, this is equivalent to a call to <a href="#QuantumPropagators.set_state!-Tuple{QuantumPropagators.AbstractPropagator, Any}"><code>set_state!</code></a> follow by a call to <a href="#QuantumPropagators.set_t!-Tuple{Any, Any}"><code>set_t!</code></a>, but some propagators may have additional requirements on re-initialization, such as refreshing expansion coefficients for <a href="#QuantumPropagators.ChebyPropagator"><code>ChebyPropagator</code></a>. In this case, the <code>kwargs</code> may be additional keyword arguments specific to the concrete type of propagator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/propagator.jl#L283-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.reinit_prop!-Tuple{QuantumPropagators.ChebyPropagator, Any}" href="#QuantumPropagators.reinit_prop!-Tuple{QuantumPropagators.ChebyPropagator, Any}"><code>QuantumPropagators.reinit_prop!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reinit_prop!(
    propagator::ChebyPropagator,
    state;
    transform_control_ranges=((c, ϵ_min, ϵ_max, check) =&gt; (ϵ_min, ϵ_max)),
    kwargs...
)</code></pre><p>re-initializes an existing <a href="#QuantumPropagators.ChebyPropagator"><code>ChebyPropagator</code></a>. This may or may not involve recalculating the Chebychev coefficients based on the current control amplitudes in <code>propagator.parameters</code>.</p><p><strong>Method-specific keyword arguments</strong></p><ul><li><p><code>transform_control_ranges</code>: a function <code>(c, ϵ_min, ϵ_max, check) =&gt; (ϵ_min′, ϵ_max′)</code>. For each control <code>c</code>, the function is called with <code>check=true</code> and <code>ϵ_min</code> (<code>ϵ_max</code>) the current minimum (maximum) values for the control from <code>propagator.parameters</code>). The Chebychev coefficients will be recalculated if the existing coefficients were obtained assuming a range for <code>c</code> outside the <em>returned</em> <code>ϵ_min′, ϵ_max′</code>.</p><p>If the coefficients do need to be recalculated, <code>transform_control_ranges</code> is called a second time with <code>check=false</code>, and the returned <code>(ϵ_min′, ϵ_max′)</code> are used for estimating the new spectral range.</p><p>For example,</p><pre><code class="nohighlight hljs">function transform_control_ranges(c, ϵ_min, ϵ_max, check)
    if check
        return (min(ϵ_min, 2 * ϵ_min), max(ϵ_max, 2 * ϵ_max))
    else
        return (min(ϵ_min, 5 * ϵ_min), max(ϵ_max, 5 * ϵ_max))
    end
end</code></pre><p>will re-calculate the Chebychev coefficients only if the current amplitudes differ by more than a factor of two from the ranges that were used when initializing the propagator (<code>control_ranges</code> parameter in <a href="#QuantumPropagators.init_prop-Tuple{Any, Any, Any, Val{:Cheby}}"><code>init_prop</code></a>, which would have had to overestimate the actual amplitudes by at least a factor of two).  When re-calculating, the <code>control_ranges</code> will overestimate the amplitudes by a factor of five. With this <code>transform_control_ranges</code>, the propagation will be stable as long as the amplitudes do not change dynamically by more than a factor of 2.5 from their original range, while also not re-calculating coefficients unnecessarily in each pass because of modest changes in the amplitudes.</p><p>The <code>transform_control_ranges</code> argument is only relevant in the context of optimal control, where the same <code>propagator</code> will be used for many iterations with changing control field amplitudes.</p></li></ul><p>All other keyword arguments are ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/cheby_propagator.jl#L185-L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.set_state!-Tuple{QuantumPropagators.AbstractPropagator, Any}" href="#QuantumPropagators.set_state!-Tuple{QuantumPropagators.AbstractPropagator, Any}"><code>QuantumPropagators.set_state!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set the current <code>state</code> of the <code>propagator</code>.</p><pre><code class="language-julia hljs">set_state!(propagator, state)</code></pre><p>sets the <code>propagator.state</code> property and returns <code>propagator.state</code>. In order to mutate the current state after a call to <a href="#QuantumPropagators.prop_step!"><code>prop_step!</code></a>, the following pattern is recommended:</p><pre><code class="nohighlight hljs">Ψ = propagator.state
foo_mutate!(Ψ)
set_state!(propagator, Ψ)</code></pre><p>where <code>foo_mutate!</code> is some function that mutates <code>Ψ</code>.  This is guaranteed to work efficiently both for in-place and not-in-place propagators, without incurring unnecessary copies.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><pre><code class="nohighlight hljs">foo_mutate!(propagator.state)</code></pre><p>by itself is not a safe operation. Always follow it by</p><pre><code class="nohighlight hljs">set_state!(propagator, propagator.state)</code></pre></div></div><p><strong>See also</strong></p><ul><li><a href="#QuantumPropagators.set_t!-Tuple{Any, Any}"><code>set_t!</code></a> — set <code>propagator.t</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/propagator.jl#L331-L367">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.set_t!-Tuple{Any, Any}" href="#QuantumPropagators.set_t!-Tuple{Any, Any}"><code>QuantumPropagators.set_t!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set the current time for the propagation.</p><pre><code class="language-julia hljs">set_t!(propagator, t)</code></pre><p>Sets <code>propagator.t</code> to the given value of <code>t</code>, where <code>t</code> must be an element of <code>propagator.tlist</code>.</p><p><strong>See also</strong></p><ul><li><a href="#QuantumPropagators.set_state!-Tuple{QuantumPropagators.AbstractPropagator, Any}"><code>set_state!</code></a> — set <code>propagator.state</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/propagator.jl#L380-L393">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.timings_enabled-Tuple{}" href="#QuantumPropagators.timings_enabled-Tuple{}"><code>QuantumPropagators.timings_enabled</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Check whether the collection of <code>TimerOutputs</code> data is active.</p><pre><code class="language-julia hljs">QuantumPropagators.timings_enabled()</code></pre><p>returns <code>true</code> if <a href="#QuantumPropagators.enable_timings-Tuple{}"><code>QuantumPropagators.enable_timings()</code></a> was called, and <code>false</code> otherwise or after <a href="#QuantumPropagators.disable_timings-Tuple{}"><code>QuantumPropagators.disable_timings()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/timings.jl#L42-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Generators.Generator" href="#QuantumPropagators.Generators.Generator"><code>QuantumPropagators.Generators.Generator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A time-dependent generator.</p><pre><code class="language-julia hljs">Generator(ops::Vector{OT}, amplitudes::Vector{AT})</code></pre><p>produces an object of type <code>Generator{OT,AT}</code> that represents</p><p class="math-container">\[Ĥ(t)= Ĥ_0 + \sum_l a_l(\{ϵ_{l&#39;}(t)\}, t) \, Ĥ_l\,,\]</p><p>where <span>$Ĥ_l$</span> are the <code>ops</code> and <span>$a_l(t)$</span> are the <code>amplitudes</code>. <span>$Ĥ(t)$</span> and <span>$Ĥ_l$</span> may represent operators in Hilbert space or super-operators in Liouville space. If the number of <code>amplitudes</code> is less than the number of <code>ops</code>, the first <code>ops</code> are considered as drift terms (<span>$Ĥ_0$</span>, respectively subsequent terms with <span>$a_l ≡ 1$</span>). At least one time-dependent amplitude is required. Each amplitude may depend on one or more control functions <span>$ϵ_{l&#39;}(t)$</span>, although most typically <span>$a_l(t) ≡ ϵ_l(t)$</span>, that is, the <code>amplitudes</code> are simply a vector of the controls. See <a href="#QuantumPropagators.Generators.hamiltonian-Tuple"><code>hamiltonian</code></a> for details.</p><p>A <code>Generator</code> object should generally not be instantiated directly, but via <a href="#QuantumPropagators.Generators.hamiltonian-Tuple"><code>hamiltonian</code></a> or <a href="#QuantumPropagators.Generators.liouvillian"><code>liouvillian</code></a>.</p><p>The list of <code>ops</code> and <code>amplitudes</code> are properties of the <code>Generator</code>. They should not be mutated.</p><p><strong>See also</strong></p><ul><li><a href="#QuantumPropagators.Generators.Operator"><code>Operator</code></a> for static generators, which may be obtained from a <code>Generator</code> via <a href="#QuantumPropagators.Controls.evaluate-Tuple{Any, Vararg{Any}}"><code>evaluate</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/generators.jl#L11-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Generators.Operator" href="#QuantumPropagators.Generators.Operator"><code>QuantumPropagators.Generators.Operator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A static operator in Hilbert or Liouville space.</p><pre><code class="language-julia hljs">Operator(ops::Vector{OT}, coeffs::Vector{CT})</code></pre><p>produces an object of type <code>Operator{OT,CT}</code> that encapsulates the &quot;lazy&quot; sum</p><p class="math-container">\[Ĥ = \sum_l c_l Ĥ_l\,,\]</p><p>where <span>$Ĥ_l$</span> are the <code>ops</code> and <span>$c_l$</span> are the <code>coeffs</code>, which each must be a constant <code>Number</code>. If the number of coefficients is less than the number of operators, the first <code>ops</code> are considered to have <span>$c_l = 1$</span>.</p><p>An <code>Operator</code> object would generally not be instantiated directly, but be obtained from a <a href="#QuantumPropagators.Generators.Generator"><code>Generator</code></a> via <a href="#QuantumPropagators.Controls.evaluate-Tuple{Any, Vararg{Any}}"><code>evaluate</code></a>.</p><p>The <span>$Ĥ_l$</span> in the sum are considered immutable. This implies that an <code>Operator</code> can be updated in-place with <a href="#QuantumPropagators.Controls.evaluate!-Tuple{Any, Tuple, Vararg{Any}}"><code>evaluate!</code></a> by only changing the <code>coeffs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/generators.jl#L88-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Generators.ScaledOperator" href="#QuantumPropagators.Generators.ScaledOperator"><code>QuantumPropagators.Generators.ScaledOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A static operator with a scalar pre-factor.</p><pre><code class="language-julia hljs">op = ScaledOperator(α, Ĥ)</code></pre><p>represents the &quot;lazy&quot; product <span>$α Ĥ$</span> where <span>$Ĥ$</span> is an operator (typically an <a href="#QuantumPropagators.Generators.Operator"><code>Operator</code></a> instance) and <span>$α$</span> is a scalar.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/generators.jl#L192-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Generators.hamiltonian-Tuple" href="#QuantumPropagators.Generators.hamiltonian-Tuple"><code>QuantumPropagators.Generators.hamiltonian</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Initialize a (usually time-dependent) Hamiltonian.</p><p>The most common usage is, e.g.,</p><pre><code class="language-julia hljs">using QuantumPropagators

H₀ = ComplexF64[0 0; 0 1];
H₁ = ComplexF64[0 1; 1 0];
ϵ₁(t) = 1.0;

hamiltonian(H₀, (H₀, ϵ₁))

# output

Generator with 2 ops and 1 amplitudes
 ops::Vector{Matrix{ComplexF64}}:
  ComplexF64[0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 1.0 + 0.0im]
  ComplexF64[0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 1.0 + 0.0im]
 amplitudes::Vector{typeof(ϵ₁)}:
  ϵ₁</code></pre><p>In general,</p><pre><code class="language-julia hljs">H = hamiltonian(terms...; check=true)</code></pre><p>constructs a Hamiltonian based on the given <code>terms</code>. Each term must be an operator or a tuple <code>(op, ampl)</code> of an operator and a control amplitude. Single operators are considered &quot;drift&quot; terms.</p><p>In most cases, each control amplitude will simply be a control function or vector of pulse values. In general, <code>ampl</code> can be an arbitrary object that depends on one or more controls, which must be obtainable via <a href="#QuantumPropagators.Controls.get_controls-Tuple{ControlProblem}"><code>get_controls(ampl)</code></a>. See <code>QuantumPropagators.Interfaces.check_amplitude</code> for the required interface.</p><p>The <code>hamiltonian</code> function will generally return a <a href="#QuantumPropagators.Generators.Generator"><code>Generator</code></a> instance. However, if none of the given terms are time-dependent, it may return a static operator (e.g., an <code>AbstractMatrix</code> or <a href="#QuantumPropagators.Generators.Operator"><code>Operator</code></a>):</p><pre><code class="language-julia hljs">hamiltonian(H₀)
# output
2×2 Matrix{ComplexF64}:
 0.0+0.0im  0.0+0.0im
 0.0+0.0im  1.0+0.0im</code></pre><pre><code class="language-julia hljs">hamiltonian(H₀, (H₁, 2.0))
# output
Operator with 2 ops and 1 coeffs
 ops::Vector{Matrix{ComplexF64}}:
  ComplexF64[0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 1.0 + 0.0im]
  ComplexF64[0.0 + 0.0im 1.0 + 0.0im; 1.0 + 0.0im 0.0 + 0.0im]
 coeffs: [2.0]</code></pre><p>The <code>hamiltonian</code> function may generate warnings if the <code>terms</code> are of an unexpected type or structure.  These can be suppressed with <code>check=false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/generators.jl#L263-L328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Generators.liouvillian" href="#QuantumPropagators.Generators.liouvillian"><code>QuantumPropagators.Generators.liouvillian</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Construct a Liouvillian <a href="#QuantumPropagators.Generators.Generator"><code>Generator</code></a>.</p><pre><code class="language-julia hljs">ℒ = liouvillian(Ĥ, c_ops=(); convention=:LvN, check=true)</code></pre><p>calculates the sparse Liouvillian super-operator <code>ℒ</code> from the Hamiltonian <code>Ĥ</code> and a list <code>c_ops</code> of Lindblad operators.</p><p>With <code>convention=:LvN</code>, applying the resulting <code>ℒ</code> to a vectorized density matrix <code>ρ⃗</code> calculates <span>$\frac{d}{dt} \vec{\rho}(t) = ℒ \vec{\rho}(t)$</span> equivalent to the Liouville-von-Neumann equation for the density matrix <span>$ρ̂$</span>,</p><p class="math-container">\[\frac{d}{dt} ρ̂(t)
= -i [Ĥ, ρ̂(t)] + \sum_k\left(
    Â_k ρ̂ Â_k^\dagger
    - \frac{1}{2} A_k^\dagger Â_k ρ̂
    - \frac{1}{2} ρ̂ Â_k^\dagger Â_k
  \right)\,,\]</p><p>where the Lindblad operators <span>$Â_k$</span> are the elements of <code>c_ops</code>.</p><p>The Hamiltonian <span>$Ĥ$</span> will generally be time-dependent. For example, it may be a <a href="#QuantumPropagators.Generators.Generator"><code>Generator</code></a> as returned by <a href="#QuantumPropagators.Generators.hamiltonian-Tuple"><code>hamiltonian</code></a>. For example, for a Hamiltonian with the terms <code>(Ĥ₀, (Ĥ₁, ϵ₁), (Ĥ₂, ϵ₂))</code>, where <code>Ĥ₀</code>, <code>Ĥ₁</code>, <code>Ĥ₂</code> are matrices, and <code>ϵ₁</code> and <code>ϵ₂</code> are functions of time, the resulting <code>ℒ</code> will be a <a href="#QuantumPropagators.Generators.Generator"><code>Generator</code></a> corresponding to terms <code>(ℒ₀, (ℒ₁, ϵ₁), (ℒ₂, ϵ₂))</code>, where the initial terms is the superoperator <code>ℒ₀</code> for the static component of the Liouvillian, i.e., the commutator with the drift Hamiltonian <code>Ĥ₀</code>, plus the dissipator (sum over <span>$k$</span>), as a sparse matrix. Time-dependent Lindblad operators are not currently supported. The remaining elements are tuples <code>(ℒ₁, ϵ₁)</code> and <code>(ℒ₂, ϵ₂)</code> corresponding to the commutators with the two control Hamiltonians, where <code>ℒ₁</code> and <code>ℒ₂</code> again are sparse matrices.</p><p>If <span>$Ĥ$</span> is not time-dependent, the resulting <code>ℒ</code> will likewise be a static operator. Passing <code>H=nothing</code> with non-empty <code>c_ops</code> initializes a pure dissipator.</p><p>With <code>convention=:TDSE</code>, the Liouvillian will be constructed for the equation of motion <span>$i \hbar \frac{d}{dt} \vec{\rho}(t) = ℒ \vec{\rho}(t)$</span> to match exactly the form of the time-dependent Schrödinger equation. While this notation is not standard in the literature of open quantum systems, it has the benefit that the resulting <code>ℒ</code> can be used in a numerical propagator for a (non-Hermitian) Schrödinger equation without any change. Thus, for numerical applications, <code>convention=:TDSE</code> is generally preferred. The returned <code>ℒ</code> between the two conventions differs only by a factor of <span>$i$</span>, since we generally assume <span>$\hbar=1$</span>.</p><p>The <code>convention</code> keyword argument is mandatory, to force a conscious choice.</p><p>See <a href="https://arxiv.org/abs/1312.0111v2">Goerz et. al. &quot;Optimal control theory for a unitary operation under dissipative evolution&quot;, arXiv 1312.0111v2, Appendix B.2</a> for the explicit construction of the Liouvillian superoperator as a sparse matrix.</p><p>Passing <code>check=false</code>, suppresses warnings and errors about unexpected types or the structure of the arguments, cf. <a href="#QuantumPropagators.Generators.hamiltonian-Tuple"><code>hamiltonian</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/generators.jl#L471-L531">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Arnoldi.arnoldi!-Union{Tuple{T}, Tuple{Matrix{ComplexF64}, Array{T}, Int64, T, Any}, Tuple{Matrix{ComplexF64}, Array{T}, Int64, T, Any, Float64}} where T" href="#QuantumPropagators.Arnoldi.arnoldi!-Union{Tuple{T}, Tuple{Matrix{ComplexF64}, Array{T}, Int64, T, Any}, Tuple{Matrix{ComplexF64}, Array{T}, Int64, T, Any, Float64}} where T"><code>QuantumPropagators.Arnoldi.arnoldi!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">m = arnoldi!(Hess, q, m, Ψ, H, dt=1.0; extended=true, norm_min=1e-15)</code></pre><p>Calculate the Hessenberg matrix and Arnoldi vectors of <code>H dt</code>, from <code>Ψ</code>.</p><p>For a given order <code>m</code>, the <code>m×m</code> Hessemberg matrix is calculated and stored in in the pre-allocated <code>Hess</code>. Further  an array of <code>m</code> normalized Arnoldi vectors is stored in in the pre-allocated <code>q</code>, plus one additional unnormalized Arnoldi vector.  The unnormalized <code>m+1</code>st vector could be used to easily extend a given <code>m×m</code> Hessenberg matrix to a <code>(m+1)×(m+1)</code> matrix.</p><p>If the extended Hessenberg matrix is requested (<code>extended=true</code>, default), the <code>m+1</code>st Arnoldi vector is also normalized, and it&#39;s norm will be stored in <code>m+1, m</code> entry of the (extended) Hessenberg matrix, which is an <code>(m+1)×(m+1)</code> matrix.</p><p>Return the size <code>m</code> of the calculated Hessenberg matrix. This will usually be the input <code>m</code>, except when the Krylov dimension of <code>H</code> starting from <code>Ψ</code> is less then <code>m</code>. E.g., if <code>Ψ</code> is an eigenstate of <code>H</code>, the returned <code>m</code> will be 1.</p><p>See <a href="https://en.wikipedia.org/wiki/Arnoldi_iteration">https://en.wikipedia.org/wiki/Arnoldi_iteration</a> for a description of the algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>Hess::Matrix{ComplexF64}</code>: Pre-allocated storage for the Hessemberg matrix.  Can be uninitialized on input. The matrix must be at least of size <code>m×m</code>, or  <code>(m+1)×(m+1)</code> if <code>extended=true</code>. On output, the <code>m×m</code> sub-matrix of <code>Hess</code>  (with the returned output <code>m</code>) will contain the Hessenberg matrix, and all  other elements of <code>Hess</code> be be set to zero.</li><li><code>q</code>: Pre-allocated array of states similar to <code>Ψ</code>, as storage for the calculated Arnoldi vectors. These may be un-initialized on input. Must be at least of length <code>m+1</code></li><li><code>m</code>: The requested dimensions of the output Hessenberg matrix.</li><li><code>Ψ</code>: The starting vector for the Arnoldi procedure. This can be of any type,  as long as <code>Φ = H * Ψ</code> results in a vector similar to <code>Ψ</code>, there is an inner  products of <code>Φ</code> and <code>Ψ</code> (<code>Ψ⋅Φ</code> is defined), and <code>norm(Ψ)</code> is defined.</li><li><code>H</code>: The operator (up to <code>dt</code>) for which to calculate the Arnoldi procedure. Can be of any type, as long as <code>H * Ψ</code> is defined.</li><li><code>dt</code>: The implicit time step; the total operator for which to calculate the Arnoldi procedure is <code>H * dt</code></li><li><code>extended</code>: If <code>true</code> (default), calculate the extended Hessenberg matrix, and normalized the final Arnoldi vector</li><li><code>norm_min</code>: the minimum value of the norm of <code>Ψ</code> at which <code>Ψ</code> should be  considered the zero vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/arnoldi.jl#L11-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Arnoldi.diagonalize_hessenberg_matrix-Tuple{Any, Any}" href="#QuantumPropagators.Arnoldi.diagonalize_hessenberg_matrix-Tuple{Any, Any}"><code>QuantumPropagators.Arnoldi.diagonalize_hessenberg_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diagonalize_hessenberg_matrix(Hess, m; accumulate=false)</code></pre><p>Diagonalize the m × m top left submatrix of the given Hessenberg matrix.</p><p>If <code>accumulate</code> is <code>true</code>, return the concatenated eigenvalues for <code>Hess[1:1,1:1]</code> to <code>Hess[1:m,1:m]</code>, that is, all sumatrices of size 1 through <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/arnoldi.jl#L132-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Arnoldi.extend_arnoldi!" href="#QuantumPropagators.Arnoldi.extend_arnoldi!"><code>QuantumPropagators.Arnoldi.extend_arnoldi!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Extend dimension of Hessenberg matrix by one.</p><pre><code class="language-julia hljs">extend_arnoldi!(Hess, q, m, H, dt; norm_min=1e-15)</code></pre><p>extends the entries in <code>Hess</code> from size (m-1)×(m-1) to size m×m, and the list <code>q</code> of Arnoldi vectors from m to (m+1). It is assumed that the input <code>Hess</code> was created by a call to <a href="#QuantumPropagators.Arnoldi.arnoldi!-Union{Tuple{T}, Tuple{Matrix{ComplexF64}, Array{T}, Int64, T, Any}, Tuple{Matrix{ComplexF64}, Array{T}, Int64, T, Any, Float64}} where T"><code>arnoldi!</code></a> with <code>extended=false</code> or a previous call to <code>extend_arnoldi!</code>. Note that <code>Hess</code> itself is not resized, so it must be allocated to size m×m or greater on input.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/arnoldi.jl#L103-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Interfaces.check_amplitude-Tuple{Any}" href="#QuantumPropagators.Interfaces.check_amplitude-Tuple{Any}"><code>QuantumPropagators.Interfaces.check_amplitude</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Check amplitude appearing in <a href="#QuantumPropagators.Generators.Generator"><code>Generator</code></a>.</p><pre><code class="language-julia hljs">@test check_amplitude(ampl; tlist, quiet=false)</code></pre><p>verifies that the given <code>ampl</code> is a valid element in the list of <code>amplitudes</code> of a <a href="#QuantumPropagators.Generators.Generator"><code>Generator</code></a> object. Specifically:</p><ul><li><a href="#QuantumPropagators.Controls.get_controls-Tuple{ControlProblem}"><code>get_controls(ampl)</code></a> must be defined and return a tuple</li><li>all controls in <code>ampl</code> must pass <a href="#QuantumPropagators.Interfaces.check_control-Tuple{Any}"><code>check_control</code></a></li><li><a href="#QuantumPropagators.Controls.substitute-Tuple{ControlProblem, Any}"><code>substitute(ampl, controls_replacements)</code></a> must be defined</li><li><a href="#QuantumPropagators.Controls.evaluate-Tuple{Any, Vararg{Any}}"><code>evaluate(ampl, tlist, n)</code></a> must be defined and return a Number</li><li><a href="#QuantumPropagators.Controls.evaluate-Tuple{Any, Vararg{Any}}"><code>evaluate(ampl, tlist, n; vals_dict)</code></a> must be defined and return a Number</li></ul><p>If <code>for_parameterization</code> (may require the <code>RecursiveArrayTools</code> package to be loaded):</p><ul><li><a href="#QuantumPropagators.Controls.get_parameters-Tuple{ControlProblem}"><code>get_parameters(ampl)</code></a> must be defined and return a vector of floats. Mutating that vector must mutate the controls inside the <code>ampl</code>.</li></ul><p>The function returns <code>true</code> for a valid amplitude and <code>false</code> for an invalid amplitude. Unless <code>quiet=true</code>, it will log an error to indicate which of the conditions failed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/interfaces/amplitude.jl#L6-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Interfaces.check_control-Tuple{Any}" href="#QuantumPropagators.Interfaces.check_control-Tuple{Any}"><code>QuantumPropagators.Interfaces.check_control</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Check that <code>control</code> can be evaluated on a time grid.</p><pre><code class="language-julia hljs">@test check_control(
    control;
    tlist,
    for_parameterization=true,
    for_time_continuous=(control isa Function),
    quiet=false
)</code></pre><p>verifies the given <code>control</code> (one of the elements of the tuple returned by <a href="#QuantumPropagators.Controls.get_controls-Tuple{ControlProblem}"><code>get_controls</code></a>):</p><ul><li><a href="#QuantumPropagators.Controls.evaluate-Tuple{Any, Vararg{Any}}"><code>evaluate(control, tlist, n)</code></a> must be defined and return a <code>Float64</code></li><li><a href="#QuantumPropagators.Controls.evaluate-Tuple{Any, Vararg{Any}}"><code>evaluate(control, tlist, n; vals_dict=IdDict(control =&gt; v))</code></a> must be defined and return <code>v</code></li><li><a href="#QuantumPropagators.Controls.discretize-Tuple{Function, Any}"><code>discretize(control, tlist)</code></a> must be defined and return a vector of floats of the same size as <code>tlist</code>. Only if <code>length(tlist) &gt; 2</code>.</li><li>all values in <a href="#QuantumPropagators.Controls.discretize-Tuple{Function, Any}"><code>discretize(control, tlist)</code></a> must be finite (<code>isfinite</code>).</li><li><a href="#QuantumPropagators.Controls.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>discretize_on_midpoints(control, tlist)</code></a> must be defined and return a vector of floats with one element less than <code>tlist</code>. Only if <code>length(tlist) &gt; 2</code>.</li><li>all values in <a href="#QuantumPropagators.Controls.discretize-Tuple{Function, Any}"><code>discretize_on_midpoints(control, tlist)</code></a> must be finite (<code>isfinite</code>)</li></ul><p>If <code>for_time_continuous</code>:</p><ul><li><a href="#QuantumPropagators.Controls.evaluate-Tuple{Any, Vararg{Any}}"><code>evaluate(control, t)</code></a> must be defined and return a <code>Float64</code></li><li><a href="#QuantumPropagators.Controls.evaluate-Tuple{Any, Vararg{Any}}"><code>evaluate(control, t; vals_dict=IdDict(control =&gt; v))</code></a> must be defined and return <code>v</code></li></ul><p>If <code>for_parameterization</code>:</p><ul><li><a href="#QuantumPropagators.Controls.get_parameters-Tuple{ControlProblem}"><code>get_parameters(control)</code></a> must be defined and return a vector of floats. Mutating that vector must mutate the control.</li></ul><p>The function returns <code>true</code> for a valid control and <code>false</code> for an invalid control. Unless <code>quiet=true</code>, it will log an error to indicate which of the conditions failed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/interfaces/control.jl#L6-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Interfaces.check_generator-Tuple{Any}" href="#QuantumPropagators.Interfaces.check_generator-Tuple{Any}"><code>QuantumPropagators.Interfaces.check_generator</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Check the dynamical <code>generator</code> for propagating <code>state</code> over <code>tlist</code>.</p><pre><code class="language-julia hljs">@test check_generator(
    generator; state, tlist,
    for_pwc=true, for_time_continuous=false,
    for_expval=true, for_parameterization=false,
    atol=1e-14, quiet=false)</code></pre><p>verifies the given <code>generator</code>:</p><ul><li><a href="#QuantumPropagators.Controls.get_controls-Tuple{ControlProblem}"><code>get_controls(generator)</code></a> must be defined and return a tuple</li><li>all controls returned by <a href="#QuantumPropagators.Controls.get_controls-Tuple{ControlProblem}"><code>get_controls(generator)</code></a> must pass <a href="#QuantumPropagators.Interfaces.check_control-Tuple{Any}"><code>check_control</code></a></li><li><a href="#QuantumPropagators.Controls.substitute-Tuple{ControlProblem, Any}"><code>substitute(generator, replacements)</code></a> must be defined</li><li>If <code>generator</code> is a <a href="#QuantumPropagators.Generators.Generator"><code>Generator</code></a> instance, all elements of <code>generator.amplitudes</code> must pass <a href="#QuantumPropagators.Interfaces.check_amplitude-Tuple{Any}"><code>check_amplitude</code></a> with <code>for_parameterization</code>.</li></ul><p>If <code>for_pwc</code> (default):</p><ul><li><a href="#QuantumPropagators.Controls.evaluate-Tuple{Any, Vararg{Any}}"><code>op = evaluate(generator, tlist, n)</code></a> must return a valid operator (<a href="#QuantumPropagators.Interfaces.check_operator-Tuple{Any}"><code>check_operator</code></a>), with forwarded keyword arguments (including <code>for_expval</code>)</li><li>If <code>QuantumPropagators.Interfaces.supports_inplace(op)</code> is <code>true</code>, <a href="#QuantumPropagators.Controls.evaluate!-Tuple{Any, Tuple, Vararg{Any}}"><code>evaluate!(op, generator, tlist, n)</code></a> must be defined</li></ul><p>If <code>for_time_continuous</code>:</p><ul><li><p><a href="#QuantumPropagators.Controls.evaluate-Tuple{Any, Vararg{Any}}"><code>evaluate(generator, t)</code></a> must return a valid operator (<a href="#QuantumPropagators.Interfaces.check_operator-Tuple{Any}"><code>check_operator</code></a>), with forwarded keyword arguments (including <code>for_expval</code>)</p></li><li><p>If <code>QuantumPropagators.Interfaces.supports_inplace(op)</code> is <code>true</code>, <a href="#QuantumPropagators.Controls.evaluate!-Tuple{Any, Tuple, Vararg{Any}}"><code>evaluate!(op, generator, t)</code></a> must be defined</p></li></ul><p>If <code>for_parameterization</code> (may require the <code>RecursiveArrayTools</code> package to be loaded):</p><ul><li><a href="#QuantumPropagators.Controls.get_parameters-Tuple{ControlProblem}"><code>get_parameters(generator)</code></a> must be defined and return a vector of floats. Mutating that vector must mutate the controls inside the <code>generator</code>.</li></ul><p>The function returns <code>true</code> for a valid generator and <code>false</code> for an invalid generator. Unless <code>quiet=true</code>, it will log an error to indicate which of the conditions failed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/interfaces/generator.jl#L4-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Interfaces.check_operator-Tuple{Any}" href="#QuantumPropagators.Interfaces.check_operator-Tuple{Any}"><code>QuantumPropagators.Interfaces.check_operator</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Check that <code>op</code> is a valid operator that can be applied to <code>state</code>.</p><pre><code class="language-julia hljs">@test check_operator(op; state, tlist=[0.0, 1.0],
                     for_expval=true, atol=1e-14, quiet=false)</code></pre><p>verifies the given <code>op</code> relative to <code>state</code>. The <code>state</code> must pass <a href="#QuantumPropagators.Interfaces.check_state-Tuple{Any}"><code>check_state</code></a>.</p><p>An &quot;operator&quot; is any object that <a href="#QuantumPropagators.Controls.evaluate-Tuple{Any, Vararg{Any}}"><code>evaluate</code></a> returns when evaluating a time-dependent dynamic generator. The specific requirements for <code>op</code> are:</p><ul><li><code>op</code> must not be time-dependent: <a href="#QuantumPropagators.Controls.evaluate-Tuple{Any, Vararg{Any}}"><code>evaluate(op, tlist, 1) ≡ op</code></a></li><li><code>op</code> must not contain any controls: <a href="#QuantumPropagators.Controls.get_controls-Tuple{ControlProblem}"><code>length(get_controls(op)) == 0</code></a></li><li><code>op * state</code> must be defined</li><li>The <a href="#QuantumPropagators.Interfaces.supports_inplace-Tuple{Vector{ComplexF64}}"><code>QuantumPropagators.Interfaces.supports_inplace</code></a> method must be defined for <code>op</code>. If it returns <code>true</code>, it must be possible to evaluate a generator in-place into the existing <code>op</code>. See <a href="#QuantumPropagators.Interfaces.check_generator-Tuple{Any}"><code>check_generator</code></a>.</li></ul><p>If <a href="#QuantumPropagators.Interfaces.supports_inplace-Tuple{Vector{ComplexF64}}"><code>QuantumPropagators.Interfaces.supports_inplace(state)</code></a>:</p><ul><li>The 3-argument <code>LinearAlgebra.mul!</code> must apply <code>op</code> to the given <code>state</code></li><li>The 5-argument <code>LinearAlgebra.mul!</code> must apply <code>op</code> to the given <code>state</code></li><li><code>LinearAlgebra.mul!</code> must match <code>*</code>, if applicable</li><li><code>LinearAlgebra.mul!</code> must return the resulting state</li></ul><p>If <code>for_expval</code> (typically required for optimal control):</p><ul><li><code>LinearAlgebra.dot(state, op, state)</code> must return return a number</li><li><code>dot(state, op, state)</code> must match <code>dot(state, op * state)</code>, if applicable</li></ul><p>The function returns <code>true</code> for a valid operator and <code>false</code> for an invalid operator. Unless <code>quiet=true</code>, it will log an error to indicate which of the conditions failed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/interfaces/operator.jl#L7-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Interfaces.check_parameterized-Tuple{Any}" href="#QuantumPropagators.Interfaces.check_parameterized-Tuple{Any}"><code>QuantumPropagators.Interfaces.check_parameterized</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Check that that the object supports the parameterization interface.</p><pre><code class="language-julia hljs">@test check_parameterized(object; name=&quot;::$typeof(object))&quot;, quiet=false)</code></pre><p>verifies that the given <code>object</code>:</p><ul><li>can be passed to <a href="#QuantumPropagators.Controls.get_parameters-Tuple{ControlProblem}"><code>get_parameters</code></a>, which must return an <code>AbstractVector</code> of <code>Float64</code></li><li>is mutated by mutating the <code>parameters</code> obtained by <code>get_parameters</code></li></ul><p><strong>See also</strong></p><ul><li><a href="#QuantumPropagators.Interfaces.check_parameterized_function-Tuple{Any}"><code>check_parameterized_function</code></a> is <code>object</code> is a <a href="#QuantumPropagators.Controls.ParameterizedFunction"><code>ParameterizedFunction</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/interfaces/parameterization.jl#L76-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Interfaces.check_parameterized_function-Tuple{Any}" href="#QuantumPropagators.Interfaces.check_parameterized_function-Tuple{Any}"><code>QuantumPropagators.Interfaces.check_parameterized_function</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Check a <a href="#QuantumPropagators.Controls.ParameterizedFunction"><code>ParameterizedFunction</code></a> instance.</p><pre><code class="language-julia hljs">@test check_parameterized_function(f; tlist; quiet=false)</code></pre><p>verifies that the given <code>f</code>:</p><ul><li>is an instance of <a href="#QuantumPropagators.Controls.ParameterizedFunction"><code>ParameterizedFunction</code></a>.</li><li>has a field <code>parameters</code> that is an <code>AbstractVector{Float64}</code>.</li><li>is a <a href="https://docs.julialang.org/en/v1/manual/methods/#Function-like-objects">callable</a> as <code>f(t)</code> for values of <code>t</code> in <code>tlist</code>, returning a <code>Float64</code>.</li><li><a href="#QuantumPropagators.Controls.get_parameters-Tuple{ControlProblem}"><code>get_parameters</code></a> provides access to the <code>parameters</code> field.</li><li>passes <a href="#QuantumPropagators.Interfaces.check_parameterized-Tuple{Any}"><code>check_parameterized</code></a></li></ul><p><strong>See also</strong></p><ul><li><a href="#QuantumPropagators.Interfaces.check_parameterized-Tuple{Any}"><code>check_parameterized</code></a> for objects that have parameters (<a href="#QuantumPropagators.Controls.get_parameters-Tuple{ControlProblem}"><code>get_parameters</code></a>), but are not instances of <a href="#QuantumPropagators.Controls.ParameterizedFunction"><code>ParameterizedFunction</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/interfaces/parameterization.jl#L5-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Interfaces.check_propagator-Tuple{Any}" href="#QuantumPropagators.Interfaces.check_propagator-Tuple{Any}"><code>QuantumPropagators.Interfaces.check_propagator</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Check that the given <code>propagator</code> implements the required interface.</p><pre><code class="language-julia hljs">@test check_propagator(propagator; atol=1e-14, quiet=false)</code></pre><p>verifies that the <code>propagator</code> matches the interface described for an <a href="#QuantumPropagators.AbstractPropagator"><code>AbstractPropagator</code></a>. The <code>propagator</code> must have been freshly initialized with <a href="#QuantumPropagators.init_prop-Tuple{Any, Any, Any, Val{:Cheby}}"><code>init_prop</code></a>.</p><ul><li><code>propagator</code> must have the properties <code>state</code>, <code>tlist</code>, <code>t</code>, <code>parameters</code>, <code>backward</code>, and <code>inplace</code></li><li><code>propagator.state</code> must be a valid state (see <a href="#QuantumPropagators.Interfaces.check_state-Tuple{Any}"><code>check_state</code></a>)</li><li>If <code>propagator.inplace</code> is true, <a href="#QuantumPropagators.Interfaces.supports_inplace-Tuple{Vector{ComplexF64}}"><code>supports_inplace</code></a> for <code>propagator.state</code> must also be true</li><li><code>propagator.tlist</code> must be monotonically increasing.</li><li><code>propagator.t</code> must be the first or last element of <code>propagator.tlist</code>, depending on <code>propagator.backward</code></li><li><a href="#QuantumPropagators.prop_step!"><code>prop_step!(propagator)</code></a> must be defined and return a valid state until the time grid is exhausted</li><li>For an in-place propagator, the state returned by <a href="#QuantumPropagators.prop_step!"><code>prop_step!</code></a> must be the <code>propagator.state</code> object</li><li>For a not-in-place propagator, the state returned by <a href="#QuantumPropagators.prop_step!"><code>prop_step!</code></a> must be a new object</li><li><a href="#QuantumPropagators.prop_step!"><code>prop_step!</code></a> must advance <code>propagator.t</code> forward or backward one step on the time grid</li><li><a href="#QuantumPropagators.prop_step!"><code>prop_step!</code></a> must return <code>nothing</code> when going beyond the time grid</li><li><a href="#QuantumPropagators.set_t!-Tuple{Any, Any}"><code>set_t!(propagator, t)</code></a> must be defined and set <code>propagator.t</code></li><li><a href="#QuantumPropagators.set_state!-Tuple{QuantumPropagators.AbstractPropagator, Any}"><code>set_state!(propagator, state)</code></a> must be defined and set <code>propagator.state</code>.</li><li><a href="#QuantumPropagators.set_state!-Tuple{QuantumPropagators.AbstractPropagator, Any}"><code>set_state!(propagator, state)</code></a> for an in-place propagator   must overwrite <code>propagator.state</code> in-place.</li><li><a href="#QuantumPropagators.set_state!-Tuple{QuantumPropagators.AbstractPropagator, Any}"><code>set_state!</code></a> must return the set <code>propagator.state</code></li><li>In a <a href="#QuantumPropagators.PiecewisePropagator"><code>PiecewisePropagator</code></a>, <code>propagator.parameters</code> must be a dict mapping controls to a vector of values, one for each interval on <code>propagator.tlist</code></li><li><a href="#QuantumPropagators.reinit_prop!-Tuple{Any, Any}"><code>reinit_prop!</code></a> must be defined and re-initialize the propagator</li><li><a href="#QuantumPropagators.reinit_prop!-Tuple{Any, Any}"><code>reinit_prop!(propagator, state)</code></a> must be idempotent. That is, repeated calls to <a href="#QuantumPropagators.reinit_prop!-Tuple{Any, Any}"><code>reinit_prop!</code></a> leave the <code>propagator</code> unchanged.</li></ul><p>The function returns <code>true</code> for a valid propagator and <code>false</code> for an invalid propagator. Unless <code>quiet=true</code>, it will log an error to indicate which of the conditions failed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/interfaces/propagator.jl#L10-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Interfaces.check_state-Tuple{Any}" href="#QuantumPropagators.Interfaces.check_state-Tuple{Any}"><code>QuantumPropagators.Interfaces.check_state</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Check that <code>state</code> is a valid element of a Hilbert space.</p><pre><code class="language-julia hljs">@test check_state(state; normalized=false, atol=1e-15, quiet=false)</code></pre><p>verifies the following requirements:</p><ul><li>The inner product (<code>LinearAlgebra.dot</code>) of two states must return a Complex number.</li><li>The <code>LinearAlgebra.norm</code> of <code>state</code> must be defined via the inner product. This is the <em>definition</em> of a Hilbert space, a.k.a a &quot;complete inner product space&quot; or more precisely a &quot;Banach space (normed vector space) where the norm is induced by an inner product&quot;.</li><li>The <a href="#QuantumPropagators.Interfaces.supports_inplace-Tuple{Vector{ComplexF64}}">`QuantumPropagators.Interfaces.supports_inplace</a> method must be defined for <code>state</code></li></ul><p>Any <code>state</code> must support the following not-in-place operations:</p><ul><li><code>state + state</code> and <code>state - state</code> must be defined</li><li><code>copy(state)</code> must be defined and return an object of the same type as <code>state</code></li><li><code>c * state</code> for a scalar <code>c</code> must be defined</li><li><code>norm(state + state)</code> must fulfill the triangle inequality</li><li><code>zero(state)</code> must be defined and produce a state with norm 0</li><li><code>0.0 * state</code> must produce a state with norm 0</li><li><code>copy(state) - state</code> must have norm 0</li><li><code>norm(state)</code> must have absolute homogeneity: <code>norm(s * state) = s * norm(state)</code></li></ul><p>If <code>supports_inplace(state)</code> is <code>true</code>, the <code>state</code> must also support the following:</p><ul><li><code>similar(state)</code> must be defined and return a valid state of the same type a <code>state</code></li><li><code>copyto!(other, state)</code> must be defined</li><li><code>fill!(state, c)</code> must be defined</li><li><code>LinearAlgebra.lmul!(c, state)</code> for a scalar <code>c</code> must be defined</li><li><code>LinearAlgebra.axpy!(c, state, other)</code> must be defined</li><li><code>norm(state)</code> must fulfill the same general mathematical norm properties as for the non-in-place norm.</li></ul><p>If <code>normalized</code> (not required by default):</p><ul><li><code>LinearAlgebra.norm(state)</code> must be 1</li></ul><p>It is strongly recommended to always support immutable operations (also for mutable states)</p><p>The function returns <code>true</code> for a valid state and <code>false</code> for an invalid state. Unless <code>quiet=true</code>, it will log an error to indicate which of the conditions failed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/interfaces/state.jl#L6-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Interfaces.check_tlist-Tuple{Any}" href="#QuantumPropagators.Interfaces.check_tlist-Tuple{Any}"><code>QuantumPropagators.Interfaces.check_tlist</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Check that the given <code>tlist</code> is valid.</p><pre><code class="language-julia hljs">@test check_tlist(tlist; quiet=false)</code></pre><p>verifies the given time grid. A valid time grid must</p><ul><li>be a <code>Vector{Float64}</code>,</li><li>contain at least two points (beginning and end),</li><li>be monotonically increasing</li></ul><p>The function returns <code>true</code> for a valid time grid and <code>false</code> for an invalid time grid. Unless <code>quiet=true</code>, it will log an error to indicated which of the conditions failed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/interfaces/tlist.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Interfaces.supports_inplace-Tuple{Vector{ComplexF64}}" href="#QuantumPropagators.Interfaces.supports_inplace-Tuple{Vector{ComplexF64}}"><code>QuantumPropagators.Interfaces.supports_inplace</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Indicate whether a given state or operator supports in-place operations</p><pre><code class="language-julia hljs">supports_inplace(state)</code></pre><p>Indicates that propagators can assume that the in-place requirements defined in <a href="#QuantumPropagators.Interfaces.check_state-Tuple{Any}"><code>QuantumPropagators.Interfaces.check_state</code></a> hold. States with in-place support must also fulfill specific properties when interacting with operators, see <a href="#QuantumPropagators.Interfaces.check_operator-Tuple{Any}"><code>QuantumPropagators.Interfaces.check_operator</code></a>.</p><pre><code class="language-julia hljs">supports_inplace(op)</code></pre><p>Indicates that the operator can be evaluated in-place with <a href="#QuantumPropagators.Controls.evaluate!-Tuple{Any, Tuple, Vararg{Any}}"><code>evaluate!</code></a>, see <a href="#QuantumPropagators.Interfaces.check_generator-Tuple{Any}"><code>QuantumPropagators.Interfaces.check_generator</code></a></p><p>Note that <code>supports_inplace</code> is not quite the same as <a href="https://docs.julialang.org/en/v1/base/base/#Base.ismutable"><code>Base.ismutable</code></a>: When using <a href="https://docs.julialang.org/en/v1/manual/types/#Mutable-Composite-Types">custom structs</a> for states or operators, even if those structs are not defined as <code>mutable</code>, they may still define the in-place interface (typically because their <em>components</em> are mutable).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/interfaces/supports_inplace.jl#L5-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Controls.ParameterizedFunction" href="#QuantumPropagators.Controls.ParameterizedFunction"><code>QuantumPropagators.Controls.ParameterizedFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for function-like objects with <a href="#QuantumPropagators.Controls.get_parameters-Tuple{ControlProblem}"><code>parameters</code></a>.</p><p>A struct that is an implementation of a <code>ParameterizedFunction</code>:</p><ul><li>must have a <code>parameters</code> field that is an <code>AbstractVector</code> of floats (e.g., a <a href="https://jonniedie.github.io/ComponentArrays.jl/stable/api/#ComponentArrays.ComponentVector"><code>ComponentArrays.ComponentVector</code></a>)</li><li>must be <a href="https://docs.julialang.org/en/v1/manual/methods/#Function-like-objects">callable</a> with a single float argument <code>t</code>,</li><li>may define getters and setters for referencing the values in <code>parameters</code> with convenient names.</li></ul><p>The <code>parameters</code> field of any <code>ParameterizedFunction</code> can be accessed via <a href="#QuantumPropagators.Controls.get_parameters-Tuple{ControlProblem}"><code>get_parameters</code></a>.</p><p>See <a href="https://juliaquantumcontrol.github.io/QuantumPropagators.jl/dev/howto/#howto_parameterized">How to define a parameterized control</a> for an example. You may use the <a href="#QuantumPropagators.Interfaces.check_parameterized_function-Tuple{Any}"><code>QuantumPropagators.Interfaces.check_parameterized_function</code></a> to check the implementation of a <code>ParameterizedFunction</code> subtype.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/controls.jl#L620-L639">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Controls.discretize-Tuple{Function, Any}" href="#QuantumPropagators.Controls.discretize-Tuple{Function, Any}"><code>QuantumPropagators.Controls.discretize</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate <code>control</code> at every point of <code>tlist</code>.</p><pre><code class="language-julia hljs">values = discretize(control, tlist; via_midpoints=true)</code></pre><p>discretizes the given <code>control</code> to a Vector of values defined on the points of <code>tlist</code>.</p><p>If <code>control</code> is a function, it is first evaluated at the midpoint of <code>tlist</code>, see <a href="#QuantumPropagators.Controls.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>discretize_on_midpoints</code></a>, and then the values on the midpoints are converted to values on <code>tlist</code>. This discretization is more stable than directly evaluating the control function at the values of <code>tlist</code>, and ensures that repeated round-trips between <a href="#QuantumPropagators.Controls.discretize-Tuple{Function, Any}"><code>discretize</code></a> and <a href="#QuantumPropagators.Controls.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>discretize_on_midpoints</code></a> can be done safely, see the note in the documentation of <a href="#QuantumPropagators.Controls.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>discretize_on_midpoints</code></a>.</p><p>The latter can still be achieved by passing <code>via_midpoints=false</code>. While such a direct discretization is suitable e.g. for plotting, but it is unsuitable for round-trips between <a href="#QuantumPropagators.Controls.discretize-Tuple{Function, Any}"><code>discretize</code></a> and <a href="#QuantumPropagators.Controls.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>discretize_on_midpoints</code></a>  (constant controls on <code>tlist</code> may result in a zig-zag on the intervals of <code>tlist</code>).</p><p>If <code>control</code> is a vector, a copy of <code>control</code> will be returned if it is of the same length as <code>tlist</code>. Otherwise, <code>control</code> must have one less value than <code>tlist</code>, and is assumed to be defined on the midpoints of <code>tlist</code>. In that case, <a href="#QuantumPropagators.Controls.discretize-Tuple{Function, Any}"><code>discretize</code></a> acts as the inverse of <a href="#QuantumPropagators.Controls.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>discretize_on_midpoints</code></a>. See <a href="#QuantumPropagators.Controls.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>discretize_on_midpoints</code></a> for how control values on <code>tlist</code> and control values on the intervals of <code>tlist</code> are related.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/controls.jl#L12-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Controls.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function" href="#QuantumPropagators.Controls.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>QuantumPropagators.Controls.discretize_on_midpoints</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate <code>control</code> at the midpoints of <code>tlist</code>.</p><pre><code class="language-julia hljs">values = discretize_on_midpoints(control, tlist)</code></pre><p>discretizes the given <code>control</code> to a Vector of values on the midpoints of <code>tlist</code>. Hence, the resulting <code>values</code> will contain one less value than <code>tlist</code>.</p><p>If <code>control</code> is a vector of values defined on <code>tlist</code> (i.e., of the same length as <code>tlist</code>), it will be converted to a vector of values on the intervals of <code>tlist</code>. The value for the first and last &quot;midpoint&quot; will remain the original values at the beginning and end of <code>tlist</code>, in order to ensure exact boundary conditions. For all other midpoints, the value for that midpoint will be calculated by &quot;un-averaging&quot;.</p><p>For example, for a <code>control</code> and <code>tlist</code> of length 5, consider the following diagram:</p><pre><code class="nohighlight hljs">tlist index:       1   2   3   4   5
tlist:             ⋅   ⋅   ⋅   ⋅   ⋅   input values cᵢ (i ∈ 1..5)
                   |̂/ ̄ ̄ ̂\ / ̂\ / ̂ ̄ ̄\|̂
midpoints:         x     x   x     x   output values pᵢ (i ∈ 1..4)
midpoints index:   1     2   3     4</code></pre><p>We will have <span>$p₁=c₁$</span> for the first value, <span>$p₄=c₅$</span> for the last value. For all other points, the control values <span>$cᵢ = \frac{p_{i-1} + p_{i}}{2}$</span> are the average of the values on the midpoints. This implies the &quot;un-averaging&quot; for the midpoint values <span>$pᵢ = 2 c_{i} - p_{i-1}$</span>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>An arbitrary input <code>control</code> array may not be compatible with the above averaging formula. In this case, the conversion will be &quot;lossy&quot; (<a href="#QuantumPropagators.Controls.discretize-Tuple{Function, Any}"><code>discretize</code></a> will not recover the original <code>control</code> array; the difference should be considered a &quot;discretization error&quot;). However, any <em>further</em> round-trip conversions between points and intervals are bijective and preserve the boundary conditions. In this case, the <a href="#QuantumPropagators.Controls.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>discretize_on_midpoints</code></a> and <a href="#QuantumPropagators.Controls.discretize-Tuple{Function, Any}"><code>discretize</code></a> methods are each other&#39;s inverse. This also implies that for an optimal control procedure, it is safe to modify <em>midpoint</em> values. Modifying the the values on the time grid directly on the other hand may accumulate discretization errors.</p></div></div><p>If <code>control</code> is a vector of one less length than <code>tlist</code>, a copy of <code>control</code> will be returned, under the assumption that the input is already properly discretized.</p><p>If <code>control</code> is a function, the function will be directly evaluated at the midpoints marked as <code>x</code> in the above diagram..</p><p><strong>See also</strong></p><ul><li><a href="#QuantumPropagators.Controls.get_tlist_midpoints-Tuple{AbstractVector}"><code>get_tlist_midpoints</code></a> – get all the midpoints on which the control will be discretized.</li><li><a href="#QuantumPropagators.Controls.t_mid-Tuple{Any, Any}"><code>t_mid</code></a> – get a particular midpoint.</li><li><a href="#QuantumPropagators.Controls.discretize-Tuple{Function, Any}"><code>discretize</code></a> – discretize directly on <code>tlist</code> instead of on the midpoints</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/controls.jl#L123-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Controls.evaluate!-Tuple{Any, Tuple, Vararg{Any}}" href="#QuantumPropagators.Controls.evaluate!-Tuple{Any, Tuple, Vararg{Any}}"><code>QuantumPropagators.Controls.evaluate!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Update an existing evaluation of a <code>generator</code>.</p><pre><code class="language-julia hljs">evaluate!(op, generator, args..; vals_dict=IdDict())</code></pre><p>performs an in-place update on an <code>op</code> the was obtained from a previous call to <a href="#QuantumPropagators.Controls.evaluate-Tuple{Any, Vararg{Any}}"><code>evaluate</code></a> with the same <code>generator</code>, but for a different point in time and/or different values in <code>vals_dict</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/controls.jl#L428-L438">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Controls.evaluate-Tuple{Any, Vararg{Any}}" href="#QuantumPropagators.Controls.evaluate-Tuple{Any, Vararg{Any}}"><code>QuantumPropagators.Controls.evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate all controls.</p><p>In general, <code>evaluate(object, args...; vals_dict=IdDict())</code> evaluates the <code>object</code> for a specific point in time indicated by the positional <code>args</code>. Any control in <code>object</code> is evaluated at the specified point in time. Alternatively, the <code>vals_dict</code> maps a controls to value (&quot;plug in this value for the given control&quot;)</p><p>For example,</p><pre><code class="language-julia hljs">op = evaluate(generator, t)</code></pre><p>evaluates <code>generator</code> at time <code>t</code>. This requires that any control in <code>generator</code> is a callable that takes <code>t</code> as a single argument.</p><pre><code class="language-julia hljs">op = evaluate(generator, tlist, n)</code></pre><p>evaluates <code>generator</code> for the n&#39;th interval of <code>tlist</code>. This uses the definitions for the midpoints in <a href="#QuantumPropagators.Controls.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>discretize_on_midpoints</code></a>. The controls in <code>generator</code> may be vectors (see <a href="#QuantumPropagators.Controls.discretize-Tuple{Function, Any}"><code>discretize</code></a>, <a href="#QuantumPropagators.Controls.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>discretize_on_midpoints</code></a>) or callables of <code>t</code>.</p><pre><code class="language-julia hljs">op = evaluate(generator, t; vals_dict)
op = evaluate(generator, tlist, n; vals_dict)</code></pre><p>resolves any explicit time dependencies in <code>generator</code> at the specified point in time, but uses the value in the given <code>vals_dict</code> for any control in <code>vals_dict</code>.</p><pre><code class="language-julia hljs">a = evaluate(ampl, tlist, n; vals_dict=IdDict())
a = evaluate(ampl, t; vals_dict=IdDict())</code></pre><p>evaluates a control amplitude to a scalar by evaluating any explicit time dependency, and by replacing each control with the corresponding value in <code>vals_dict</code>.</p><p>Calling <code>evaluate</code> for an object with no implicit or explicit time dependence should return the object unchanged.</p><p>For generators without any explicit time dependence,</p><pre><code class="language-julia hljs">op = evaluate(generator; vals_dict)</code></pre><p>can be used. The <code>vals_dict</code> in this case must contain values for all controls in <code>generator</code>.</p><p><strong>See also:</strong></p><ul><li><a href="#QuantumPropagators.Controls.evaluate!-Tuple{Any, Tuple, Vararg{Any}}"><code>evaluate!</code></a> — update an existing operator with a re-evaluation of a</li></ul><p>generator at a different point in time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/controls.jl#L236-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Controls.get_controls-Tuple{AbstractMatrix}" href="#QuantumPropagators.Controls.get_controls-Tuple{AbstractMatrix}"><code>QuantumPropagators.Controls.get_controls</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_controls(operator)</code></pre><p>for a static operator (matrix) returns an empty tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/controls.jl#L223-L229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Controls.get_controls-Tuple{Function}" href="#QuantumPropagators.Controls.get_controls-Tuple{Function}"><code>QuantumPropagators.Controls.get_controls</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Extract a Tuple of controls.</p><pre><code class="language-julia hljs">controls = get_controls(generator)</code></pre><p>extracts the controls from a single dynamical generator.</p><p>For example, if <code>generator = hamiltonian(H0, (H1, ϵ1), (H2, ϵ2))</code>, extracts <code>(ϵ1, ϵ2)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/controls.jl#L207-L218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Controls.get_parameters-Tuple{Any}" href="#QuantumPropagators.Controls.get_parameters-Tuple{Any}"><code>QuantumPropagators.Controls.get_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Obtain analytic parameters of the given <code>control</code>.</p><pre><code class="language-julia hljs">parameters = get_parameters(control)</code></pre><p>obtains <code>parameters</code> as an <code>AbstractVector{Float64}</code> containing any tunable analytic parameters associated with the <code>control</code>. The specific type of <code>parameters</code> depends on how <code>control</code> is defined, but a <a href="https://jonniedie.github.io/ComponentArrays.jl/stable/api/#ComponentArrays.ComponentVector"><code>ComponentArrays.ComponentVector</code></a> should be a common array type.</p><p>Mutating the resulting vector must directly affect the control in any subsequent call to <a href="#QuantumPropagators.Controls.evaluate-Tuple{Any, Vararg{Any}}"><code>evaluate</code></a>. That is, the values in <code>parameters</code> must alias values inside the <code>control</code>.</p><p>Note that the <code>control</code> must be an object specifically designed to have analytic parameters. Typically, it should be implemented as a subtype of <a href="#QuantumPropagators.Controls.ParameterizedFunction"><code>ParameterizedFunction</code></a>. For a simple function <code>ϵ(t)</code> or a vector of pulse values, which are the default types of controls discussed in the documentation of <a href="#QuantumPropagators.Generators.hamiltonian-Tuple"><code>hamiltonian</code></a>, the <code>get_parameters</code> function will return an empty vector.</p><p>More generally,</p><pre><code class="language-julia hljs">parameters = get_parameters(object)</code></pre><p>collects and combines all unique parameter arrays from the controls inside the <code>object</code>. The <code>object</code> may be a <a href="#QuantumPropagators.Generators.Generator"><code>Generator</code></a>, <a href="#QuantumControlBase.Trajectory"><code>Trajectory</code></a>, <a href="#QuantumControlBase.ControlProblem"><code>ControlProblem</code></a>, or any other object for which <a href="#QuantumPropagators.Controls.get_controls-Tuple{ControlProblem}"><code>get_controls(object)</code></a> is defined. If there are multiple controls with different parameter arrays, these are combined in a <a href="https://docs.sciml.ai/RecursiveArrayTools/stable/array_types/#RecursiveArrayTools.ArrayPartition"><code>RecursiveArrayTools.ArrayPartition</code></a>. This requires the <code>RecursiveArrayTools</code> package to be loaded. Again, mutating <code>parameters</code> directly affects the underlying controls.</p><p>The <code>parameters</code> may be used as part of the <code>parameters</code> attribute of a propagator for time-continuous dynamics, like a general ODE solver, or in an optimization that tunes analytic control parameters, e.g., with a Nelder-Mead method. Examples might include the widths, peak amplitudes, and times of a superposition of Gaussians [<a href="../references/#MachnesPRL2018">9</a>], cf. the <a href="https://juliaquantumcontrol.github.io/QuantumPropagators.jl/dev/howto/#howto_parameterized">example of a <code>ParameterizedFunction</code></a>, or the amplitudes associated with spectral components in a random truncated basis [<a href="../references/#CanevaPRA2011">10</a>].</p><p>The <code>parameters</code> are not intended for optimization methods such as <a href="https://juliaquantumcontrol.github.io/GRAPE.jl/stable/">GRAPE</a> or <a href="https://juliaquantumcontrol.github.io/Krotov.jl/stable/">Krotov</a> that fundamentally use a piecewise-constant control ansatz. In the context of such methods, the &quot;control parameters&quot; are always the amplitudes of the <code>control</code> at the mid-points of the time grid, as obtained by <a href="#QuantumPropagators.Controls.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>discretize_on_midpoints</code></a>, and <code>get_parameters</code> is ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/controls.jl#L514-L571">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Controls.get_tlist_midpoints-Tuple{AbstractVector}" href="#QuantumPropagators.Controls.get_tlist_midpoints-Tuple{AbstractVector}"><code>QuantumPropagators.Controls.get_tlist_midpoints</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Shift time grid values to the interval midpoints</p><pre><code class="language-julia hljs">tlist_midpoints = get_tlist_midpoints(
    tlist; preserve_start=true, preserve_end=true
)</code></pre><p>takes a vector <code>tlist</code> of length <span>$n$</span> and returns a <code>Vector{Float64}</code> of length <span>$n-1$</span> containing the midpoint values of each interval. The intervals in <code>tlist</code> are not required to be uniform.</p><p>By default, the first and last point of <code>tlist</code> is preserved, see <a href="#QuantumPropagators.Controls.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>discretize_on_midpoints</code></a>. This behavior can be disabled by passing <code>preserve_start</code> and <code>preserve_end</code> as <code>false</code> in order to use the midpoints of the first and last interval, respectively.</p><p><strong>See also</strong></p><ul><li><a href="#QuantumPropagators.Controls.t_mid-Tuple{Any, Any}"><code>t_mid</code></a> – get a particular midpoint.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/controls.jl#L71-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Controls.substitute-Union{Tuple{T}, Tuple{T, Any}} where T" href="#QuantumPropagators.Controls.substitute-Union{Tuple{T}, Tuple{T, Any}} where T"><code>QuantumPropagators.Controls.substitute</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Substitute inside the given object.</p><pre><code class="language-julia hljs">object = substitute(object, replacements)</code></pre><p>returns a modified object with the replacements defined in the given <code>replacements</code> dictionary. Things that can be replaced include operators, controls, and amplitudes. For example,</p><pre><code class="language-julia hljs">generator = substitute(generator::Generator, replacements)
operator = substitute(operator::Operator, replacements)
amplitude = substitute(amplitude, controls_replacements)</code></pre><p>Note that <code>substitute</code> cannot be used to replace dynamic quantities, e.g. controls, with static value. Use <a href="#QuantumPropagators.Controls.evaluate-Tuple{Any, Vararg{Any}}"><code>evaluate</code></a> instead for that purpose.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/controls.jl#L474-L493">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Controls.t_mid-Tuple{Any, Any}" href="#QuantumPropagators.Controls.t_mid-Tuple{Any, Any}"><code>QuantumPropagators.Controls.t_mid</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Midpoint of n&#39;th interval of tlist.</p><pre><code class="language-julia hljs">t = t_mid(tlist, n)</code></pre><p>returns the <code>t</code> that is the midpoint between points <code>tlist[n+1]</code> and <code>tlist[n]</code>, but snapping to the beginning/end to follow the convention explained in <a href="#QuantumPropagators.Controls.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>discretize_on_midpoints</code></a> (to preserve exact boundary conditions at the edges of the time grid.)</p><p><strong>See also</strong></p><ul><li><a href="#QuantumPropagators.Controls.get_tlist_midpoints-Tuple{AbstractVector}"><code>get_tlist_midpoints</code></a> – get all the midpoints in one go.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/controls.jl#L312-L327">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Storage.get_from_storage!-Tuple{Any, AbstractVector, Any}" href="#QuantumPropagators.Storage.get_from_storage!-Tuple{Any, AbstractVector, Any}"><code>QuantumPropagators.Storage.get_from_storage!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Obtain data from storage.</p><pre><code class="language-julia hljs">get_from_storage!(data, storage, i)</code></pre><p>extracts data from the <code>storage</code> for the i&#39;th time slot. Inverse of <a href="#QuantumPropagators.Storage.write_to_storage!-Tuple{AbstractVector, Integer, Any}"><code>write_to_storage!</code></a>. This modifies <code>data</code> in-place. If <code>get_from_storage!</code> is implemented for arbitrary <code>observables</code>, it is the developer&#39;s responsibility that <a href="#QuantumPropagators.Storage.init_storage-Tuple{Any, AbstractVector}"><code>init_storage</code></a>,  <a href="#QuantumPropagators.Storage.write_to_storage!-Tuple{AbstractVector, Integer, Any}"><code>write_to_storage!</code></a>, and <code>get_from_storage!</code> are compatible.</p><p>To extract immutable <code>data</code>, the non-in-place version</p><pre><code class="language-julia hljs">data = get_from_storage(storage, i)</code></pre><p>can be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/storage.jl#L153-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Storage.get_from_storage-Tuple{AbstractVector, Any}" href="#QuantumPropagators.Storage.get_from_storage-Tuple{AbstractVector, Any}"><code>QuantumPropagators.Storage.get_from_storage</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Obtain immutable data from storage.</p><pre><code class="language-julia hljs">data = get_from_storage(storage, i)</code></pre><p>See <a href="#QuantumPropagators.Storage.get_from_storage!-Tuple{Any, AbstractVector, Any}"><code>get_from_storage!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/storage.jl#L178-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Storage.init_storage-Tuple{Any, AbstractVector}" href="#QuantumPropagators.Storage.init_storage-Tuple{Any, AbstractVector}"><code>QuantumPropagators.Storage.init_storage</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Create a <code>storage</code> array for propagation.</p><pre><code class="language-julia hljs">storage = init_storage(state, tlist)</code></pre><p>creates a storage array suitable for storing a <code>state</code> for each point in <code>tlist</code>.</p><pre><code class="language-julia hljs">storage = init_storage(state, tlist, observables)</code></pre><p>creates a storage array suitable for the data generated by the <code>observables</code> applied to <code>state</code>, see <a href="#QuantumPropagators.Storage.map_observables-NTuple{4, Any}"><code>map_observables</code></a>, for each point in <code>tlist</code>.</p><pre><code class="language-julia hljs">storage = init_storage(data, nt)</code></pre><p>creates a storage arrays suitable for storing <code>data</code> nt times, where <code>nt=length(tlist)</code>. By default, this will be a vector of <code>typeof(data)</code> and length <code>nt</code>, or a <code>n × nt</code> Matrix with the same <code>eltype</code> as <code>data</code> if <code>data</code> is a Vector of length <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/storage.jl#L8-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Storage.map_observable-Union{Tuple{ST}, Tuple{IT}, Tuple{TT}, Tuple{F}, Tuple{F, TT, IT, ST}} where {F&lt;:Function, TT, IT, ST}" href="#QuantumPropagators.Storage.map_observable-Union{Tuple{ST}, Tuple{IT}, Tuple{TT}, Tuple{F}, Tuple{F, TT, IT, ST}} where {F&lt;:Function, TT, IT, ST}"><code>QuantumPropagators.Storage.map_observable</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apply a single <code>observable</code> to <code>state</code>.</p><pre><code class="language-julia hljs">data = map_observable(observable, tlist, i, state)</code></pre><p>By default, <code>observable</code> can be one of the following:</p><ul><li>A function taking the three arguments <code>state</code>, <code>tlist</code>, <code>i</code>, where <code>state</code> is defined at time <code>tlist[i]</code>.</li><li>A function taking a single argument <code>state</code>, under the assumption that the observable is time-independent</li><li>A matrix for which to calculate the expectation value with respect to the vector <code>state</code>.</li></ul><p>The default <a href="#QuantumPropagators.Storage.map_observables-NTuple{4, Any}"><code>map_observables</code></a> delegates to this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/storage.jl#L83-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Storage.map_observables-NTuple{4, Any}" href="#QuantumPropagators.Storage.map_observables-NTuple{4, Any}"><code>QuantumPropagators.Storage.map_observables</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Obtain &quot;observable&quot; data from <code>state</code>.</p><pre><code class="language-julia hljs">data = map_observables(observables, tlist, i, state)</code></pre><p>calculates the data for a tuple of <code>observables</code> applied to <code>state</code> defined at time <code>tlist[i]</code>. For a single observable (tuple of length 1), simply return the result of <a href="#QuantumPropagators.Storage.map_observable-Union{Tuple{ST}, Tuple{IT}, Tuple{TT}, Tuple{F}, Tuple{F, TT, IT, ST}} where {F&lt;:Function, TT, IT, ST}"><code>map_observable</code></a>.</p><p>For multiple observables, return the tuple resulting from applying <a href="#QuantumPropagators.Storage.map_observable-Union{Tuple{ST}, Tuple{IT}, Tuple{TT}, Tuple{F}, Tuple{F, TT, IT, ST}} where {F&lt;:Function, TT, IT, ST}"><code>map_observable</code></a> for each observable. If the tuple is &quot;uniform&quot; (all elements are of the same type, e.g. if each observable calculates the expectation value of a Hermitian operator), it is converted to a Vector. This allows for compact storage in a storage array, see <a href="#QuantumPropagators.Storage.init_storage-Tuple{Any, AbstractVector}"><code>init_storage</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/storage.jl#L51-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Storage.write_to_storage!-Tuple{AbstractVector, Integer, Any}" href="#QuantumPropagators.Storage.write_to_storage!-Tuple{AbstractVector, Integer, Any}"><code>QuantumPropagators.Storage.write_to_storage!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Place data into <code>storage</code> for time slot <code>i</code>.</p><pre><code class="language-julia hljs">write_to_storage!(storage, i, data)</code></pre><p>for a <code>storage</code> array created by <a href="#QuantumPropagators.Storage.init_storage-Tuple{Any, AbstractVector}"><code>init_storage</code></a> stores the <code>data</code> obtained from <a href="#QuantumPropagators.Storage.map_observables-NTuple{4, Any}"><code>map_observables</code></a> at time slot <code>i</code>.</p><p>Conceptually, this corresponds roughly to <code>storage[i] = data</code>, but <code>storage</code> may have its own idea on how to store data for a specific time slot. For example, with the default <a href="#QuantumPropagators.Storage.init_storage-Tuple{Any, AbstractVector}"><code>init_storage</code></a> Vector data will be stored in a matrix, and <code>write_to_storage!</code> will in this case write data to the i&#39;th column of the matrix.</p><p>For a given type of <code>storage</code> and <code>data</code>, it is the developer&#39;s responsibility that <a href="#QuantumPropagators.Storage.init_storage-Tuple{Any, AbstractVector}"><code>init_storage</code></a> and <code>write_to_storage!</code> are compatible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/storage.jl#L126-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.SpectralRange.random_state-Tuple{Any}" href="#QuantumPropagators.SpectralRange.random_state-Tuple{Any}"><code>QuantumPropagators.SpectralRange.random_state</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Random normalized quantum state.</p><pre><code class="language-julia hljs">    Ψ = random_state(H; rng=Random.GLOBAL_RNG)</code></pre><p>returns a random normalized state compatible with the Hamiltonian <code>H</code>. This is intended to provide a starting vector for estimating the spectral radius of <code>H</code> via an Arnoldi method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/specrad.jl#L141-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.SpectralRange.ritzvals" href="#QuantumPropagators.SpectralRange.ritzvals"><code>QuantumPropagators.SpectralRange.ritzvals</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Calculate a vector for Ritz values converged to a given precision.</p><pre><code class="language-julia hljs">R = ritzvals(G, state, m_min, m_max=2*m_min; prec=1e-5, norm_min=1e-15)</code></pre><p>calculates a complex vector <code>R</code> of at least <code>m_min</code> (assuming a sufficient Krylov dimension) and at most <code>m_max</code> Ritz values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/specrad.jl#L159-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.SpectralRange.specrange-Tuple{Any, Val{:arnoldi}}" href="#QuantumPropagators.SpectralRange.specrange-Tuple{Any, Val{:arnoldi}}"><code>QuantumPropagators.SpectralRange.specrange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">E_min, E_max = specrange(
    H, :arnoldi;
    rng=Random.GLOBAL_RNG,
    state=random_state(H; rng),
    m_min=20,
    m_max=60,
    prec=1e-3,
    norm_min=1e-15,
    enlarge=true
)</code></pre><p>uses <a href="https://en.wikipedia.org/wiki/Arnoldi_iteration">Arnoldi iteration</a> with <code>state</code> as the starting vector. It approximates the eigenvalues of <code>H</code> with between <code>m_min</code> and <code>m_max</code> Ritz values, until the lowest and highest eigenvalue are stable to a relative precision of <code>prec</code>. The <code>norm_min</code> parameter is passed to the underlying <a href="#QuantumPropagators.Arnoldi.arnoldi!-Union{Tuple{T}, Tuple{Matrix{ComplexF64}, Array{T}, Int64, T, Any}, Tuple{Matrix{ComplexF64}, Array{T}, Int64, T, Any, Float64}} where T"><code>arnoldi!</code></a>.</p><p>If <code>enlarge=true</code> (default) the returned <code>E_min</code> and <code>E_max</code> will be enlarged via a heuristic to slightly over-estimate the spectral radius instead of under-estimating it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/specrad.jl#L62-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.SpectralRange.specrange-Tuple{Any, Val{:diag}}" href="#QuantumPropagators.SpectralRange.specrange-Tuple{Any, Val{:diag}}"><code>QuantumPropagators.SpectralRange.specrange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">E_min, E_max = specrange(H, :diag)</code></pre><p>uses exact diagonization via the standard <code>eigvals</code> function to obtain the smallest and largest eigenvalue. This should only be used for relatively small matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/specrad.jl#L113-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.SpectralRange.specrange-Tuple{Any, Val{:manual}}" href="#QuantumPropagators.SpectralRange.specrange-Tuple{Any, Val{:manual}}"><code>QuantumPropagators.SpectralRange.specrange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">E_min, E_max = specrange(H, :manual; E_min, E_max)</code></pre><p>directly returns the given <code>E_min</code> and <code>E_max</code> without considering <code>H</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/specrad.jl#L129-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.SpectralRange.specrange-Tuple{Any}" href="#QuantumPropagators.SpectralRange.specrange-Tuple{Any}"><code>QuantumPropagators.SpectralRange.specrange</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate the spectral range of a Hamiltonian <code>H</code> on the real axis.</p><pre><code class="language-julia hljs">E_min, E_max = specrange(H; method=:auto, kwargs...)</code></pre><p>calculates the approximate lowest and highest eigenvalues of <code>H</code>. Any imaginary part in the eigenvalues is ignored: the routine is intended for (although not strictly limited to) a Hermitian <code>H</code>.</p><p>This delegates to</p><pre><code class="language-julia hljs">specrange(H, method; kwargs...)</code></pre><p>for the different methods.</p><p>The default <code>method=:auto</code> chooses the best method for the given <code>H</code>. This is <code>:diag</code> for small matrices, and <code>:arnoldi</code> otherwise. If both <code>E_min</code> and <code>E_max</code> are given in the <code>kwargs</code>, those will be returned directly (<code>method=:manual</code>).</p><p>Keyword arguments not relevant to the underlying implementation will be ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/specrad.jl#L10-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Newton.NewtonWrk" href="#QuantumPropagators.Newton.NewtonWrk"><code>QuantumPropagators.Newton.NewtonWrk</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NewtonWrk(v0, m_max=10)</code></pre><p>Workspace for the Newton-with-restarted-Arnoldi propagation routine.</p><p>Initializes the workspace for the propagation of a vector <code>v0</code>, using a maximum Krylov dimension of <code>m_max</code> in each restart iteration. Note that <code>m_max</code> should be smaller than the length of <code>v0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/newton.jl#L12-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Newton.extend_leja!-Tuple{OffsetArrays.OffsetVector{ComplexF64, AA} where AA&lt;:AbstractVector{ComplexF64}, Any, OffsetArrays.OffsetVector{ComplexF64, AA} where AA&lt;:AbstractVector{ComplexF64}, Any}" href="#QuantumPropagators.Newton.extend_leja!-Tuple{OffsetArrays.OffsetVector{ComplexF64, AA} where AA&lt;:AbstractVector{ComplexF64}, Any, OffsetArrays.OffsetVector{ComplexF64, AA} where AA&lt;:AbstractVector{ComplexF64}, Any}"><code>QuantumPropagators.Newton.extend_leja!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extend_leja!(leja, n, newpoints, n_use)</code></pre><p>Given an array of <code>n</code> (ordered) Leja points, extract <code>n_use</code> points from <code>newpoints</code>, and append them to the existing Leja points. The array <code>leja</code> should be sufficiently large to hold the new Leja points, which are appended after index <code>n_old</code>. It will be re-allocated if necessary and may have a size of up to <code>2*(n+n_use)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>leja</code>: Array of leja values. Must contain the &quot;old&quot; leja values to be kept  in <code>leja(0:n-1)</code>. On output, <code>n_use</code> new leja points will be in  <code>leja(n+:n+n_use-1)</code>, for the original value of <code>n</code>.  The <code>leja</code> array must  use zero-based indexing.</li><li><code>n</code>: On input, number of &quot;old&quot; leja points in <code>leja</code>. On output, total number of leja points (i.e. <code>n=n+n_use</code>)</li><li><code>newpoints</code>: On input, candidate points for new leja points.  The <code>n_use</code> best values will be chosen and added to <code>leja</code>. On output, the values of <code>new_points</code> are undefined.</li><li><code>n_use</code>: Number of points that should be added to <code>leja</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/newton.jl#L73-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Newton.extend_newton_coeffs!-Tuple{OffsetArrays.OffsetVector{ComplexF64, AA} where AA&lt;:AbstractVector{ComplexF64}, Int64, OffsetArrays.OffsetVector{ComplexF64, AA} where AA&lt;:AbstractVector{ComplexF64}, Any, Int64, Float64}" href="#QuantumPropagators.Newton.extend_newton_coeffs!-Tuple{OffsetArrays.OffsetVector{ComplexF64, AA} where AA&lt;:AbstractVector{ComplexF64}, Int64, OffsetArrays.OffsetVector{ComplexF64, AA} where AA&lt;:AbstractVector{ComplexF64}, Any, Int64, Float64}"><code>QuantumPropagators.Newton.extend_newton_coeffs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extend_newton_coeffs!(a, n_a, leja, func, n_leja, radius)</code></pre><p>Extend the array <code>a</code> of existing Newton coefficients for the expansion of the <code>func</code> from <code>n_a</code> coefficients to <code>n_leja</code> coefficients. Return a new value <code>n_a=n_a+n_leja</code> with the total number of Newton coefficients in the updated <code>a</code>.</p><p><strong>Arguments</strong></p><ul><li><code>a</code>: On input, a zero-based array of length <code>n_a</code> or greater, containing Newton coefficients. On output, array containing a total <code>n_leja</code> coefficients. The array <code>a</code> will be resized if necessary, and may have a length greater than <code>n_leja</code> on output</li><li><code>n_a</code>:  The number of Newton coefficients in <code>a</code>, on input. Elements of <code>a</code>  beyond the first <code>n_a</code> elements will be overwritten.</li><li><code>leja</code>: Array of normalized Leja points, containing at least <code>n_leja</code> elements.</li><li><code>func</code>: Function for which to calculate Newton coefficients</li><li><code>n_leja</code>: The number of elements in <code>leja</code> to use for calculating new coefficients, and the total number of Newton coefficients on output</li><li><code>radius</code>: Normalization radius for divided differences</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/newton.jl#L151-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Newton.newton!-NTuple{4, Any}" href="#QuantumPropagators.Newton.newton!-NTuple{4, Any}"><code>QuantumPropagators.Newton.newton!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">newton!(Ψ, H, dt, wrk; func=(z -&gt; exp(-1im*z)), norm_min=1e-14, relerr=1e-12,
        max_restarts=50, _...)</code></pre><p>Evaluate <code>Ψ = func(H*dt) Ψ</code> using a Newton-with-restarted-Arnoldi scheme.</p><p><strong>Arguments</strong></p><ul><li><code>Ψ</code>: The state to propagate, will be overwritten in-place with the propagated state</li><li><code>H</code>: Operator acting on <code>Ψ</code>. Together with <code>dt</code>, this is the argument to <code>func</code></li><li><code>dt</code>: Implicit time step. Together with <code>H</code>, this is the argument to <code>func</code></li><li><code>wkr</code>: Work array, initialized with <a href="#QuantumPropagators.Newton.NewtonWrk"><code>NewtonWrk</code></a></li><li><code>func</code>: The function to apply to <code>H dt</code>, taking a single (scalar) complex-valued argument <code>z</code> in place of <code>H dt</code>. The default <code>func</code> is to evaluate the time evaluations operator for the Schrödinger equation</li><li><code>norm_min</code>: the minimum norm at which to consider a state similar to <code>Ψ</code> as zero</li><li><code>relerr</code>: The relative error defining the convergence condition for the restart iteration. Propagation stops when the norm of the accumulated <code>Ψ</code> is stable up to the given relative error</li><li><code>max_restarts</code>: The maximum number of restart iterations. Exceeding <code>max_restarts</code> will throw an <code>AssertionError</code>.</li></ul><p>All other keyword arguments are ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/newton.jl#L217-L245">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Cheby.ChebyWrk" href="#QuantumPropagators.Cheby.ChebyWrk"><code>QuantumPropagators.Cheby.ChebyWrk</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Workspace for the Chebychev propagation routine.</p><pre><code class="language-julia hljs">ChebyWrk(Ψ, Δ, E_min, dt; limit=1e-12)</code></pre><p>initializes the workspace for the propagation of a state similar to <code>Ψ</code> under a Hamiltonian with eigenvalues between <code>E_min</code> and <code>E_min + Δ</code>, and a time step <code>dt</code>. Chebychev coefficients smaller than the given <code>limit</code> are discarded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/cheby.jl#L75-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Cheby.cheby!-NTuple{4, Any}" href="#QuantumPropagators.Cheby.cheby!-NTuple{4, Any}"><code>QuantumPropagators.Cheby.cheby!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate <code>Ψ = exp(-𝕚 * H * dt) Ψ</code> in-place.</p><pre><code class="language-julia hljs">cheby!(Ψ, H, dt, wrk; E_min=nothing, check_normalization=false)</code></pre><p><strong>Arguments</strong></p><ul><li><code>Ψ</code>: on input, initial vector. Will be overwritten with result.</li><li><code>H</code>: Hermitian operator</li><li><code>dt</code>: time step</li><li><code>wrk</code>: internal workspace</li><li><code>E_min</code>: minimum eigenvalue of H, to be used instead of the <code>E_min</code> from the  initialization of <code>wrk</code>. The same <code>wrk</code> may be used for different values  <code>E_min</code>, as long as the spectra radius <code>Δ</code> and the time step <code>dt</code> are the  same as those used for the initialization of <code>wrk</code>.</li><li><code>check_normalizataion</code>: perform checks that the H does not exceed the spectral radius for which the workspace was initialized.</li></ul><p>The routine will not allocate any internal storage. This implementation requires <code>copyto!</code> <code>lmul!</code>, and <code>axpy!</code> to be implemented for <code>Ψ</code>, and the three-argument <code>mul!</code> for <code>Ψ</code> and <code>H</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/cheby.jl#L127-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Cheby.cheby-NTuple{4, Any}" href="#QuantumPropagators.Cheby.cheby-NTuple{4, Any}"><code>QuantumPropagators.Cheby.cheby</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate <code>Ψ = exp(-𝕚 * H * dt) Ψ</code>.</p><pre><code class="language-julia hljs">Ψ_out = cheby(Ψ, H, dt, wrk; E_min=nothing, check_normalization=false)</code></pre><p>acts like <a href="#QuantumPropagators.Cheby.cheby!-NTuple{4, Any}"><code>cheby!</code></a> but does not modify <code>Ψ</code> in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/cheby.jl#L216-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Cheby.cheby_coeffs!" href="#QuantumPropagators.Cheby.cheby_coeffs!"><code>QuantumPropagators.Cheby.cheby_coeffs!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Calculate Chebychev coefficients in-place.</p><pre><code class="language-julia hljs">n::Int = cheby_coeffs!(coeffs, Δ, dt, limit=1e-12)</code></pre><p>overwrites the first <code>n</code> values in <code>coeffs</code> with new coefficients larger than <code>limit</code> for the given new spectral radius <code>Δ</code> and time step <code>dt</code>. The <code>coeffs</code> array will be resized if necessary, and may have a length &gt; <code>n</code> on exit.</p><p>See also <a href="#QuantumPropagators.Cheby.cheby_coeffs-Tuple{Any, Any}"><code>cheby_coeffs</code></a> for an non-in-place version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/cheby.jl#L42-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.Cheby.cheby_coeffs-Tuple{Any, Any}" href="#QuantumPropagators.Cheby.cheby_coeffs-Tuple{Any, Any}"><code>QuantumPropagators.Cheby.cheby_coeffs</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate Chebychev coefficients.</p><pre><code class="language-julia hljs">a::Vector{Float64} = cheby_coeffs(Δ, dt; limit=1e-12)</code></pre><p>return an array of coefficients larger than <code>limit</code>.</p><p><strong>Arguments</strong></p><ul><li><code>Δ</code>: the spectral radius of the underlying operator</li><li><code>dt</code>: the time step</li></ul><p>See also <a href="#QuantumPropagators.Cheby.cheby_coeffs!"><code>cheby_coeffs!</code></a> for an in-place version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/v0.8.0+dev/src/cheby.jl#L10-L25">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../references/">« References</a><div class="flexbox-break"></div><p class="footer-message"><a href="https://github.com/JuliaQuantumControl/Krotov.jl">Krotov.jl</a> v0.7.0+dev docs powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Saturday 27 July 2024 16:55">Saturday 27 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
