<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Example 4 (PE) ¬∑ Krotov.jl</title><meta name="title" content="Example 4 (PE) ¬∑ Krotov.jl"/><meta property="og:title" content="Example 4 (PE) ¬∑ Krotov.jl"/><meta property="twitter:title" content="Example 4 (PE) ¬∑ Krotov.jl"/><meta name="description" content="Documentation for Krotov.jl."/><meta property="og:description" content="Documentation for Krotov.jl."/><meta property="twitter:description" content="Documentation for Krotov.jl."/><meta property="og:url" content="https://juliaquantumcontrol.github.io/Krotov.jl/examples/perfect_entanglers/"/><meta property="twitter:url" content="https://juliaquantumcontrol.github.io/Krotov.jl/examples/perfect_entanglers/"/><link rel="canonical" href="https://juliaquantumcontrol.github.io/Krotov.jl/examples/perfect_entanglers/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Krotov.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../overview/">Overview</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../">List of Examples</a></li><li><a class="tocitem" href="../simple_state_to_state/">Example 1 (TLS)</a></li><li><a class="tocitem" href="../rho_3states/">Example 2 (Diss. Gate)</a></li><li><a class="tocitem" href="../state_to_state_parametrizations/">Example 3 (Parametrization)</a></li><li class="is-active"><a class="tocitem" href>Example 4 (PE)</a><ul class="internal"><li><a class="tocitem" href="#Hamiltonian-and-guess-pulses"><span>Hamiltonian and guess pulses</span></a></li><li><a class="tocitem" href="#Logical-basis-for-two-qubit-gates"><span>Logical basis for two-qubit gates</span></a></li><li><a class="tocitem" href="#Defining-the-optimization-problem"><span>Defining the optimization problem</span></a></li><li><a class="tocitem" href="#Optimization"><span>Optimization</span></a></li><li><a class="tocitem" href="#Optimization-result"><span>Optimization result</span></a></li><li><a class="tocitem" href="#Direct-maximization-of-the-gate-concurrence"><span>Direct maximization of the gate concurrence</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Example 4 (PE)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Example 4 (PE)</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaQuantumControl/Krotov.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaQuantumControl/Krotov.jl/blob/master/examples/perfect_entanglers.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Example-4:-Optimization-for-a-perfect-entangler"><a class="docs-heading-anchor" href="#Example-4:-Optimization-for-a-perfect-entangler">Example 4: Optimization for a perfect entangler</a><a id="Example-4:-Optimization-for-a-perfect-entangler-1"></a><a class="docs-heading-anchor-permalink" href="#Example-4:-Optimization-for-a-perfect-entangler" title="Permalink"></a></h1><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>This example is also available as a Jupyter notebook: <a href="https://nbviewer.jupyter.org/github/JuliaQuantumControl/Krotov.jl/blob/gh-pages/dev/examples/perfect_entanglers.ipynb"><code>perfect_entanglers.ipynb</code></a>.</p><p>Compare this example against the <a href="https://juliaquantumcontrol.github.io/GRAPE.jl/stable/examples/perfect_entanglers/">same example using GRAPE</a>.</p></div></div><p><span>$\gdef\op#1{\hat{#1}}$</span> <span>$\gdef\init{\text{init}}$</span> <span>$\gdef\tgt{\text{tgt}}$</span></p><pre><code class="language-julia hljs">const PROJECTDIR = dirname(Base.active_project());
projectdir(names...) = joinpath(PROJECTDIR, names...);
datadir(names...) = projectdir(&quot;data&quot;, names...);</code></pre><p>This example illustrates the optimization towards a perfectly entangling two-qubit gate for a system of two transmon qubits with a shared transmission line. It uses both the indirect perfect entanglers functional shown in Goerz <em>et al.</em>, Phys. Rev. A 91, 062307 (2015) <a href="../../references/#GoerzPRA2015">[1]</a>  and a direct maximization of the gate concurrence and thus demonstrates the optimization for non-analytic functions via the calculation of gradients with automatic differentiation.</p><h2 id="Hamiltonian-and-guess-pulses"><a class="docs-heading-anchor" href="#Hamiltonian-and-guess-pulses">Hamiltonian and guess pulses</a><a id="Hamiltonian-and-guess-pulses-1"></a><a class="docs-heading-anchor-permalink" href="#Hamiltonian-and-guess-pulses" title="Permalink"></a></h2><p>We will write the Hamiltonian in units of GHz (angular frequency; the factor 2œÄ is implicit) and ns:</p><pre><code class="language-julia hljs">const GHz = 2œÄ
const MHz = 0.001GHz
const ns = 1.0
const Œºs = 1000ns;</code></pre><p>The Hamiltonian and parameters are taken from Ref.¬†<a href="../../references/#GoerzPRA2015">[1, Table 1]</a>.</p><pre><code class="language-julia hljs">‚äó = kron
const ùïö = 1im
const N = 6  # levels per transmon

using LinearAlgebra
using SparseArrays
using QuantumControl


function transmon_hamiltonian(;
    Œ©re,
    Œ©im,
    N=N,  # levels per transmon
    œâ‚ÇÅ=4.380GHz,
    œâ‚ÇÇ=4.614GHz,
    œâd=4.498GHz,
    Œ±‚ÇÅ=-210MHz,
    Œ±‚ÇÇ=-215MHz,
    J=-3MHz,
    Œª=1.03,
    use_sparse=:auto
)
    ùüô = SparseMatrixCSC{ComplexF64,Int64}(sparse(I, N, N))
    bÃÇ‚ÇÅ = spdiagm(1 =&gt; complex.(sqrt.(collect(1:N-1)))) ‚äó ùüô
    bÃÇ‚ÇÇ = ùüô ‚äó spdiagm(1 =&gt; complex.(sqrt.(collect(1:N-1))))
    bÃÇ‚ÇÅ‚Å∫ = sparse(bÃÇ‚ÇÅ&#39;)
    bÃÇ‚ÇÇ‚Å∫ = sparse(bÃÇ‚ÇÇ&#39;)
    nÃÇ‚ÇÅ = sparse(bÃÇ‚ÇÅ&#39; * bÃÇ‚ÇÅ)
    nÃÇ‚ÇÇ = sparse(bÃÇ‚ÇÇ&#39; * bÃÇ‚ÇÇ)
    nÃÇ‚ÇÅ¬≤ = sparse(nÃÇ‚ÇÅ * nÃÇ‚ÇÅ)
    nÃÇ‚ÇÇ¬≤ = sparse(nÃÇ‚ÇÇ * nÃÇ‚ÇÇ)
    bÃÇ‚ÇÅ‚Å∫_bÃÇ‚ÇÇ = sparse(bÃÇ‚ÇÅ&#39; * bÃÇ‚ÇÇ)
    bÃÇ‚ÇÅ_bÃÇ‚ÇÇ‚Å∫ = sparse(bÃÇ‚ÇÅ * bÃÇ‚ÇÇ&#39;)

    œâÃÉ‚ÇÅ = œâ‚ÇÅ - œâd
    œâÃÉ‚ÇÇ = œâ‚ÇÇ - œâd

    HÃÇ‚ÇÄ = sparse(
        (œâÃÉ‚ÇÅ - Œ±‚ÇÅ / 2) * nÃÇ‚ÇÅ +
        (Œ±‚ÇÅ / 2) * nÃÇ‚ÇÅ¬≤ +
        (œâÃÉ‚ÇÇ - Œ±‚ÇÇ / 2) * nÃÇ‚ÇÇ +
        (Œ±‚ÇÇ / 2) * nÃÇ‚ÇÇ¬≤ +
        J * (bÃÇ‚ÇÅ‚Å∫_bÃÇ‚ÇÇ + bÃÇ‚ÇÅ_bÃÇ‚ÇÇ‚Å∫)
    )

    HÃÇ‚ÇÅre = (1 / 2) * (bÃÇ‚ÇÅ + bÃÇ‚ÇÅ‚Å∫ + Œª * bÃÇ‚ÇÇ + Œª * bÃÇ‚ÇÇ‚Å∫)
    HÃÇ‚ÇÅim = (ùïö / 2) * (bÃÇ‚ÇÅ‚Å∫ - bÃÇ‚ÇÅ + Œª * bÃÇ‚ÇÇ‚Å∫ - Œª * bÃÇ‚ÇÇ)

    if ((N &lt; 5) &amp;&amp; (use_sparse ‚â¢ true)) || use_sparse ‚â° false
        H = hamiltonian(Array(HÃÇ‚ÇÄ), (Array(HÃÇ‚ÇÅre), Œ©re), (Array(HÃÇ‚ÇÅim), Œ©im))
    else
        H = hamiltonian(HÃÇ‚ÇÄ, (HÃÇ‚ÇÅre, Œ©re), (HÃÇ‚ÇÅim, Œ©im))
    end
    return H

end;</code></pre><p>We choose a pulse duration of 400 ns. The guess pulse amplitude is 35 MHz, with a 15 ns switch-on/-off time. The Hamiltonian is written in a rotating frame, so in general, the control field is allowed to be complex-valued. We separate this into two control fields, one for the real part and one for the imaginary part. Initially, the imaginary part is zero, corresponding to a field exactly at the frequency of the rotating frame.</p><pre><code class="language-julia hljs">using QuantumControl.Shapes: flattop

function guess_pulses(; T=400ns, E‚ÇÄ=35MHz, dt=0.1ns, t_rise=15ns)

    tlist = collect(range(0, T, step=dt))
    Œ©re(t) = E‚ÇÄ * flattop(t, T=T, t_rise=t_rise)
    Œ©im(t) = 0.0

    return tlist, Œ©re, Œ©im

end

tlist, Œ©re_guess, Œ©im_guess = guess_pulses();</code></pre><p>We can visualize this:</p><pre><code class="language-julia hljs">using Plots
Plots.default(
    linewidth               = 3,
    size                    = (550, 300),
    legend                  = :right,
    foreground_color_legend = nothing,
    background_color_legend = RGBA(1, 1, 1, 0.8),
)

function plot_complex_pulse(tlist, Œ©; time_unit=:ns, ampl_unit=:MHz, kwargs...)

    ax1 = plot(
        tlist ./ eval(time_unit),
        abs.(Œ©) ./ eval(ampl_unit);
        label=&quot;|Œ©|&quot;,
        xlabel=&quot;time ($time_unit)&quot;,
        ylabel=&quot;amplitude ($ampl_unit)&quot;,
        kwargs...
    )

    ax2 = plot(
        tlist ./ eval(time_unit),
        angle.(Œ©) ./ œÄ;
        label=&quot;œï(Œ©)&quot;,
        xlabel=&quot;time ($time_unit)&quot;,
        ylabel=&quot;phase (œÄ)&quot;
    )

    plot(ax1, ax2, layout=(2, 1))

end

plot_complex_pulse(tlist, Œ©re_guess.(tlist) + ùïö * Œ©im_guess.(tlist))</code></pre><img src="c8e71758.svg" alt="Example block output"/><h2 id="Logical-basis-for-two-qubit-gates"><a class="docs-heading-anchor" href="#Logical-basis-for-two-qubit-gates">Logical basis for two-qubit gates</a><a id="Logical-basis-for-two-qubit-gates-1"></a><a class="docs-heading-anchor-permalink" href="#Logical-basis-for-two-qubit-gates" title="Permalink"></a></h2><p>For simplicity, we will be define the qubits in the <em>bare</em> basis, i.e. ignoring the static coupling <span>$J$</span>.</p><pre><code class="language-julia hljs">function ket(i::Int64; N=N)
    Œ® = zeros(ComplexF64, N)
    Œ®[i+1] = 1
    return Œ®
end

function ket(indices::Int64...; N=N)
    Œ® = ket(indices[1]; N=N)
    for i in indices[2:end]
        Œ® = Œ® ‚äó ket(i; N=N)
    end
    return Œ®
end

function ket(label::AbstractString; N=N)
    indices = [parse(Int64, digit) for digit in label]
    return ket(indices...; N=N)
end

basis = [ket(&quot;00&quot;), ket(&quot;01&quot;), ket(&quot;10&quot;), ket(&quot;11&quot;)];</code></pre><h2 id="Defining-the-optimization-problem"><a class="docs-heading-anchor" href="#Defining-the-optimization-problem">Defining the optimization problem</a><a id="Defining-the-optimization-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-optimization-problem" title="Permalink"></a></h2><p>We define the optimization with one objective for each of the four basis states:</p><pre><code class="language-julia hljs">H = transmon_hamiltonian(Œ©re=Œ©re_guess, Œ©im=Œ©im_guess);

objectives = [Objective(; initial_state=Œ®, generator=H) for Œ® ‚àà basis];</code></pre><p>Note that we omit the <code>target_state</code> here. This is because we will be optimizing for an arbitrary perfect entangler, not for a specific quantum gate. Thus, there is no a-priori known target state to which the initial state must evolve.</p><p>The optimization is steered by the perfect entanglers distance measure <span>$D_{PE}$</span>, that is, the geometric distance of the quantum gate obtained from propagating the four basis states to the polyhedron of perfect entanglers in the Weyl chamber. Since the logical subspace defining the qubit is embedded in the larger Hilbert space of the transmon, there may be loss of population from the logical subspace. To counter this possibility in the optimization, we add a unitarity measure  to <span>$D_{PE}$</span>. The two terms are added with equal weight.</p><pre><code class="language-julia hljs">using TwoQubitWeylChamber: D_PE, gate_concurrence, unitarity
using QuantumControl.Functionals: gate_functional

J_T_PE = gate_functional(D_PE; unitarity_weight=0.5);</code></pre><p>The <code>gate_functional</code> routines used above converts the function <code>D_PE</code> that receives the gate <span>$UÃÇ$</span> as a 4√ó4 matrix into a functional of the correct from for the <code>QuantumControl.optimize</code> routine, which is a function of the propagated states.</p><p>We can check that for the guess pulse, we are not implementing a perfect entangler</p><pre><code class="language-julia hljs">using QuantumControl: propagate_objectives

guess_states = propagate_objectives(objectives, tlist; use_threads=true);

U_guess = [basis[i] ‚ãÖ guess_states[j] for i = 1:4, j = 1:4]

gate_concurrence(U_guess)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.7773116198510461</code></pre><p>We find that the guess pulse produces a gate in the <code>W0*</code> region of the Weyl chamber:</p><pre><code class="language-julia hljs">using TwoQubitWeylChamber: weyl_chamber_region
weyl_chamber_region(U_guess)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;W0*&quot;</code></pre><p>That is, the region of the Weyl chamber containing controlled-phase gates with a phase <span>$&gt; œÄ$</span> (Weyl chamber coordinates <span>$c‚ÇÅ &gt; œÄ/2$</span>, <span>$c‚ÇÇ &lt; œÄ/4$</span>).</p><p>This in fact allows use to use the perfect entangler functional without modification: if the guess pulse were in the &quot;W1&quot; region of the Weyl chamber, (close to SWAP), we would have to flip its sign, or we would optimize towards the local equivalence class of the SWAP gate instead of towards the perfect of perfect entanglers. In principle, we could use a modified functional that takes the absolute square of the <code>D_PE</code> term, by using</p><pre><code class="nohighlight hljs">J_T_PE = gate_functional(D_PE; unitarity_weight=0.5, absolute_square=true)</code></pre><p>This would specifically optimize for the <em>surface</em> of the perfect entanglers functional.</p><p>The guess pulse loses about 10% of population from the logical subspace:</p><pre><code class="language-julia hljs">1 - unitarity(U_guess)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.09071664593779827</code></pre><p>We can also evaluate the geometric distance to the polyhedron of perfect entanglers in the Weyl chamber:</p><pre><code class="language-julia hljs">D_PE(U_guess)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.7787454222401244</code></pre><p>Together with the unitarity measure, this is the initial value of the optimization functional:</p><pre><code class="language-julia hljs">0.5 * D_PE(U_guess) + 0.5 * (1 - unitarity(U_guess))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.43473103408896135</code></pre><pre><code class="language-julia hljs">J_T_PE(guess_states, objectives)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.43473103408896135</code></pre><h2 id="Optimization"><a class="docs-heading-anchor" href="#Optimization">Optimization</a><a id="Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization" title="Permalink"></a></h2><p>Now, we formulate the full control problem</p><pre><code class="language-julia hljs">problem = ControlProblem(
    objectives=objectives,
    lambda_a=10.0,
    update_shape=(t -&gt; flattop(t, T=400ns, t_rise=15ns, func=:blackman)),
    tlist=tlist,
    iter_stop=100,
    J_T=J_T_PE,
    check_convergence=res -&gt; begin
        (
            (res.J_T &gt; res.J_T_prev) &amp;&amp;
            (res.converged = true) &amp;&amp;
            (res.message = &quot;Loss of monotonic convergence&quot;)
        )
        (
            (res.J_T &lt;= 1e-3) &amp;&amp;
            (res.converged = true) &amp;&amp;
            (res.message = &quot;Found a perfect entangler&quot;)
        )
    end,
    use_threads=true,
);</code></pre><p>Note that we have not not given a <code>chi</code> parameter to calculate the boundary condition <span>$|œá‚Çñ‚ü© = -‚àÇJ_T/‚àÇ‚ü®œï‚Çñ|$</span> that Krotov&#39;s method requires. In this case, the Krotov.jl package will use automatic differentiation to determine the derivative. In principle, the perfect entanglers function has an analytical derivative, but it is exceedingly laborious to calculate and implement it (see the <a href="https://github.com/qucontrol/weylchamber/blob/master/src/weylchamber/perfect_entanglers.py">source code of the <code>weylchamber</code> Python package</a>, which can evaluate that derivative).</p><pre><code class="language-julia hljs">opt_result = @optimize_or_load(datadir(&quot;PE_OCT.jld2&quot;), problem; method=:Krotov);</code></pre><pre><code class="language-julia hljs">opt_result</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Krotov Optimization Result
--------------------------
- Started at 2022-10-28T20:39:44.344
- Number of objectives: 4
- Number of iterations: 27
- Value of functional: 5.44530e-04
- Reason for termination: Found a perfect entangler
- Ended at 2022-10-28T20:40:15.753 (31 seconds, 409 milliseconds)
</code></pre><h2 id="Optimization-result"><a class="docs-heading-anchor" href="#Optimization-result">Optimization result</a><a id="Optimization-result-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-result" title="Permalink"></a></h2><p>We extract the optimized control field from the optimization result and plot it</p><pre><code class="language-julia hljs">Œ©_opt = opt_result.optimized_controls[1] + ùïö * opt_result.optimized_controls[2]

plot_complex_pulse(tlist, Œ©_opt)</code></pre><img src="0e49bc4d.svg" alt="Example block output"/><p>We then propagate the optimized control field to analyze the resulting quantum gate:</p><pre><code class="language-julia hljs">using QuantumControl.Controls: substitute, get_controls

opt_states = propagate_objectives(
    substitute(
        objectives,
        IdDict(zip(get_controls(objectives), opt_result.optimized_controls))
    ),
    tlist;
    use_threads=true
);

U_opt = [basis[i] ‚ãÖ opt_states[j] for i = 1:4, j = 1:4];</code></pre><p>We find that we have achieved a perfect entangler:</p><pre><code class="language-julia hljs">gate_concurrence(U_opt)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.0</code></pre><p>Moreover, we have reduced the population loss to ‚âà 1%</p><pre><code class="language-julia hljs">1 - unitarity(U_opt)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.009864163148670446</code></pre><h2 id="Direct-maximization-of-the-gate-concurrence"><a class="docs-heading-anchor" href="#Direct-maximization-of-the-gate-concurrence">Direct maximization of the gate concurrence</a><a id="Direct-maximization-of-the-gate-concurrence-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-maximization-of-the-gate-concurrence" title="Permalink"></a></h2><p>In the previous optimizations, we have optimized for a perfect entangler indirectly via a geometric function in the Weyl chamber. The entire reason that perfect entangler functional was formulated is because calculating the gate concurrence directly involves the eigenvalues of the unitary, see <a href="../../references/#KrausPRA2001">Kraus and Cirac [2]</a> and <a href="../../references/#ChildsPRA2003">Childs *et al.* [3]</a>, which are inherently non-analytic.</p><p>However, since Krotov.jl can use automatic differentiation, this is no longer an insurmountable obstacle!</p><p>We can define a functional for a given gate <code>U</code> that combines the gate concurrence and (as above) a unitarity measure to penalize loss of population from the logical subspace:</p><pre><code class="language-julia hljs">J_T_C(U) = 0.5 * (1 - gate_concurrence(U)) + 0.5 * (1 - unitarity(U));</code></pre><p>In the optimization, we will convert this functional to one that takes the propagated states as arguments (via the <code>gate_functional</code> routine). We can do that same for the gradient: Let Zygote (the automatic differentiation framework we are using) determine the gradient for <code>J_T_C</code> with respect to <code>U</code>, but then analytically translate that into the derivative with respect to the states that we need to calculate the œá-states.</p><pre><code class="language-julia hljs">using QuantumControl.Functionals: make_gate_chi

chi_C = make_gate_chi(J_T_C, objectives);</code></pre><p>Running this, we again are able to find a perfect entangler.</p><pre><code class="language-julia hljs">opt_result_direct = @optimize_or_load(
    datadir(&quot;PE_OCT_direct.jld2&quot;),
    problem;
    method=:Krotov,
    J_T=gate_functional(J_T_C),
    chi=chi_C
);</code></pre><pre><code class="language-julia hljs">opt_result_direct</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Krotov Optimization Result
--------------------------
- Started at 2022-10-28T20:40:23.247
- Number of objectives: 4
- Number of iterations: 65
- Value of functional: 9.70036e-04
- Reason for termination: Found a perfect entangler
- Ended at 2022-10-28T20:40:40.001 (16 seconds, 754 milliseconds)
</code></pre><pre><code class="language-julia hljs">opt_states_direct = propagate_objectives(
    substitute(
        objectives,
        IdDict(zip(get_controls(objectives), opt_result_direct.optimized_controls))
    ),
    tlist;
    use_threads=true
);

U_opt_direct = [basis[i] ‚ãÖ opt_states_direct[j] for i = 1:4, j = 1:4];</code></pre><pre><code class="language-julia hljs">gate_concurrence(U_opt_direct)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.9999116674541543</code></pre><pre><code class="language-julia hljs">1 - unitarity(U_opt_direct)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.0018517393899137868</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../state_to_state_parametrizations/">¬´ Example 3 (Parametrization)</a><a class="docs-footer-nextpage" href="../../api/">API ¬ª</a><div class="flexbox-break"></div><p class="footer-message"><a href="https://github.com/JuliaQuantumControl/Krotov.jl">Krotov.jl</a> v0.5.4+dev docs powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.0 on <span class="colophon-date" title="Friday 6 October 2023 19:02">Friday 6 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
