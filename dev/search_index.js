var documenterSearchIndex = {"docs":
[{"location":"examples/rho_3states/","page":"Example 2 (Diss. Gate)","title":"Example 2 (Diss. Gate)","text":"EditURL = \"https://github.com/JuliaQuantumControl/Krotov.jl/blob/master/examples/rho_3states.jl\"","category":"page"},{"location":"examples/rho_3states/#Example-2:-Optimization-of-a-Dissipative-Quantum-Gate","page":"Example 2 (Diss. Gate)","title":"Example 2: Optimization of a Dissipative Quantum Gate","text":"","category":"section"},{"location":"examples/rho_3states/","page":"Example 2 (Diss. Gate)","title":"Example 2 (Diss. Gate)","text":"tip: Tip\nThis example is also available as a Jupyter notebook: rho_3states.ipynb.Compare this example against the same example using the krotov Python package.","category":"page"},{"location":"examples/rho_3states/","page":"Example 2 (Diss. Gate)","title":"Example 2 (Diss. Gate)","text":"gdefop1hat1 gdefinittextinit gdeftgttexttgt","category":"page"},{"location":"examples/rho_3states/","page":"Example 2 (Diss. Gate)","title":"Example 2 (Diss. Gate)","text":"This example illustrates the optimization for a quantum gate in an open quantum system, where the dynamics is governed by the Liouville-von Neumann equation.","category":"page"},{"location":"examples/rho_3states/","page":"Example 2 (Diss. Gate)","title":"Example 2 (Diss. Gate)","text":"using DrWatson\n@quickactivate \"KrotovTests\"","category":"page"},{"location":"examples/rho_3states/","page":"Example 2 (Diss. Gate)","title":"Example 2 (Diss. Gate)","text":"using QuantumControl\nusing LinearAlgebra\nusing Serialization\nusing SparseArrays","category":"page"},{"location":"examples/rho_3states/","page":"Example 2 (Diss. Gate)","title":"Example 2 (Diss. Gate)","text":"using Plots\nPlots.default(\n    linewidth               = 3,\n    size                    = (550, 300),\n    legend                  = :right,\n    foreground_color_legend = nothing,\n    background_color_legend = RGBA(1, 1, 1, 0.8),\n)","category":"page"},{"location":"examples/rho_3states/#The-two-transmon-system","page":"Example 2 (Diss. Gate)","title":"The two-transmon system","text":"","category":"section"},{"location":"examples/rho_3states/","page":"Example 2 (Diss. Gate)","title":"Example 2 (Diss. Gate)","text":"We will use internal units GHz and ns. Values in GHz contain an implicit factor 2 pi, and MHz and μs are converted to GHz and ns, respectively:","category":"page"},{"location":"examples/rho_3states/","page":"Example 2 (Diss. Gate)","title":"Example 2 (Diss. Gate)","text":"const GHz = 2π;\nconst MHz = 0.001GHz;\nconst ns = 1.0;\nconst μs = 1000ns;\nconst 𝕚 = 1im;\nnothing #hide","category":"page"},{"location":"examples/rho_3states/","page":"Example 2 (Diss. Gate)","title":"Example 2 (Diss. Gate)","text":"This implicit factor 2 pi is because frequencies (nu) convert to energies as E = h nu, but our propagation routines assume a unit hbar = 1 for energies. Thus, the factor h  hbar = 2 pi.","category":"page"},{"location":"examples/rho_3states/","page":"Example 2 (Diss. Gate)","title":"Example 2 (Diss. Gate)","text":"function transmon_liouvillian(\n    Ωre,\n    Ωim;\n    N=5,             # number of qubit levels\n    ω₁=4.3796GHz,    # qubit frequency 1\n    ω₂=4.6137GHz,    # qubit frequency 2\n    ωd=4.4985GHz,    # drive frequency\n    δ₁=-239.3MHz,    # anharmonicity 1\n    δ₂=-242.8MHz,    # anharmonicity 2\n    J=-2.3MHz,       # effective qubit-qubit coupling\n    γ₁₁=(1 / 38.0μs),  # decay rate for qubit 1\n    γ₁₂=(1 / 32.0μs),  # decay rate for qubit 2\n    γ₂₁=(1 / 29.5μs),  # dephasing rate for qubit 1\n    γ₂₂=(1 / 16.0μs)  # dephasing time for qubit 2\n)\n\n    ⊗(A, B) = kron(A, B)\n    𝟙 = SparseMatrixCSC{ComplexF64,Int64}(sparse(I, N, N))\n\n    b̂₁ = spdiagm(1 => complex.(sqrt.(collect(1:N-1)))) ⊗ 𝟙\n    b̂₂ = 𝟙 ⊗ spdiagm(1 => complex.(sqrt.(collect(1:N-1))))\n    b̂₁⁺ = sparse(b̂₁')\n    b̂₂⁺ = sparse(b̂₂')\n    n̂₁ = sparse(b̂₁' * b̂₁)\n    n̂₂ = sparse(b̂₂' * b̂₂)\n    n̂₁² = sparse(n̂₁ * n̂₁)\n    n̂₂² = sparse(n̂₂ * n̂₂)\n    b̂₁⁺_b̂₂ = sparse(b̂₁' * b̂₂)\n    b̂₁_b̂₂⁺ = sparse(b̂₁ * b̂₂')\n\n    Ĥ₀ = sparse(\n        (ω₁ - ωd - δ₁ / 2) * n̂₁ +\n        (δ₁ / 2) * n̂₁² +\n        (ω₂ - ωd - δ₂ / 2) * n̂₂ +\n        (δ₂ / 2) * n̂₂² +\n        J * (b̂₁⁺_b̂₂ + b̂₁_b̂₂⁺)\n    )\n\n    Ĥ₁re = (1 / 2) * (b̂₁ + b̂₁⁺ + b̂₂ + b̂₂⁺)\n    Ĥ₁im = (𝕚 / 2) * (b̂₁⁺ - b̂₁ + b̂₂⁺ - b̂₂)\n\n    H = (Ĥ₀, (Ĥ₁re, Ωre), (Ĥ₁im, Ωim))\n\n    c_ops = [√γ₁₁ * b̂₁, √γ₁₂ * b̂₂, √γ₂₁ * n̂₁, √γ₂₂ * n̂₂]\n\n    return liouvillian(H, c_ops; convention=:TDSE)\n\nend\n\nconst T = 400ns;\n\nΩre = t -> 35MHz * QuantumControl.Shapes.flattop(t; T=T, t_rise=20ns);\nΩim = t -> 0.0;\n\nL = transmon_liouvillian(Ωre, Ωim);\n\ntlist = collect(range(0, 400ns, length=2000));\nnothing #hide","category":"page"},{"location":"examples/rho_3states/","page":"Example 2 (Diss. Gate)","title":"Example 2 (Diss. Gate)","text":"The guess pulse looks as follows:","category":"page"},{"location":"examples/rho_3states/","page":"Example 2 (Diss. Gate)","title":"Example 2 (Diss. Gate)","text":"function plot_control(pulse::Vector, tlist)\n    plot(tlist, pulse, xlabel=\"time\", ylabel=\"amplitude\", legend=false)\nend\n\nplot_control(ϵ::T, tlist) where {T<:Function} = plot_control([ϵ(t) for t in tlist], tlist);\nnothing #hide","category":"page"},{"location":"examples/rho_3states/","page":"Example 2 (Diss. Gate)","title":"Example 2 (Diss. Gate)","text":"fig = plot_control(Ωre, tlist)","category":"page"},{"location":"examples/rho_3states/#Optimization-objectives","page":"Example 2 (Diss. Gate)","title":"Optimization objectives","text":"","category":"section"},{"location":"examples/rho_3states/","page":"Example 2 (Diss. Gate)","title":"Example 2 (Diss. Gate)","text":"Our target gate is OpO = sqrttextiSWAP:","category":"page"},{"location":"examples/rho_3states/","page":"Example 2 (Diss. Gate)","title":"Example 2 (Diss. Gate)","text":"SQRTISWAP = [\n    1  0    0   0\n    0 1/√2 𝕚/√2 0\n    0 𝕚/√2 1/√2 0\n    0  0    0   1\n];\nnothing #hide","category":"page"},{"location":"examples/rho_3states/","page":"Example 2 (Diss. Gate)","title":"Example 2 (Diss. Gate)","text":"The key idea explored in the paper is that a set of three density matrices is sufficient to track the optimization","category":"page"},{"location":"examples/rho_3states/","page":"Example 2 (Diss. Gate)","title":"Example 2 (Diss. Gate)","text":"$","category":"page"},{"location":"examples/rho_3states/","page":"Example 2 (Diss. Gate)","title":"Example 2 (Diss. Gate)","text":"\\begin{align} \\Op{\\rho}1     &= \\sum{i=1}^{d} \\frac{2 (d-i+1)}{d (d+1)} \\ketbra{i}{i} \\\n\\Op{\\rho}2     &= \\sum{i,j=1}^{d} \\frac{1}{d} \\ketbra{i}{j} \\\n\\Op{\\rho}3     &= \\sum{i=1}^{d} \\frac{1}{d} \\ketbra{i}{i} \\end{align} $","category":"page"},{"location":"examples/rho_3states/","page":"Example 2 (Diss. Gate)","title":"Example 2 (Diss. Gate)","text":"In our case, d=4 for a two qubit-gate, and the keti, ketj are the canonical basis states ket00, ket01, ket10, ket11","category":"page"},{"location":"examples/rho_3states/","page":"Example 2 (Diss. Gate)","title":"Example 2 (Diss. Gate)","text":"function ket(i::Int64; N=5)\n    Ψ = zeros(ComplexF64, N)\n    Ψ[i+1] = 1\n    return Ψ\nend;\n\nket(i::Int64, j::Int64; N=5) = kron(ket(i; N=N), ket(j; N=N));\n\nbra(args...; N=5) = adjoint(ket(args..., N=N));\n\nconst basis_labels = [(0, 0), (0, 1), (1, 0), (1, 1)];\nconst basis = [ket(labels...) for labels in basis_labels];\nconst d = length(basis);\n\nconst basis_tgt = [sum([SQRTISWAP[i, j] * basis[i] for i ∈ 1:d]) for j ∈ 1:d];\n\n\nconst ρ̂₁ =\n    sum([(2 * (d - i + 1) / (d * (d + 1))) * basis[i] * adjoint(basis[i]) for i ∈ 1:d]);\nconst ρ̂₂ = sum([(1 / d) * basis[i] * adjoint(basis[j]) for i ∈ 1:d for j ∈ 1:d]);\nconst ρ̂₃ = sum([(1 / d) * basis[i] * adjoint(basis[i]) for i ∈ 1:d]);\n\nconst ρ̂₁_tgt = sum([\n    (2 * (d - i + 1) / (d * (d + 1))) * basis_tgt[i] * adjoint(basis_tgt[i]) for i ∈ 1:d\n]);\nconst ρ̂₂_tgt =\n    sum([(1 / d) * basis_tgt[i] * adjoint(basis_tgt[j]) for i ∈ 1:d for j ∈ 1:d]);\nconst ρ̂₃_tgt = sum([(1 / d) * basis_tgt[i] * adjoint(basis_tgt[i]) for i ∈ 1:d]);\nnothing #hide","category":"page"},{"location":"examples/rho_3states/","page":"Example 2 (Diss. Gate)","title":"Example 2 (Diss. Gate)","text":"The three density matrices play different roles in the optimization, and, as shown in the paper, convergence may improve significantly by weighing the states relatively to each other. For this example, we place a strong emphasis on the optimization Oprho_1 rightarrow OpO^dagger Oprho_1 OpO, by a factor of 20. This reflects that the hardest part of the optimization is identifying the basis in which the gate is diagonal. We will be using the real-part functional (J_Ttextre) to evaluate the success of Oprho_i rightarrow OpOOprho_iOpO^dagger. Because Oprho_1 and Oprho_3 are mixed states, the Hilbert-Schmidt overlap will take values smaller than one in the optimal case. To compensate, we divide the weights by the purity of the respective states.","category":"page"},{"location":"examples/rho_3states/","page":"Example 2 (Diss. Gate)","title":"Example 2 (Diss. Gate)","text":"weights = Float64[20, 1, 1];\nweights *= length(weights) / sum(weights); # manual normalization\nweights ./= [0.3, 1.0, 0.25]; # purities\n\nconst objectives = [\n    Objective(\n        initial_state=reshape(ρ̂₁, :),\n        generator=L,\n        target_state=reshape(ρ̂₁_tgt, :),\n        weight=weights[1]\n    ),\n    Objective(\n        initial_state=reshape(ρ̂₂, :),\n        generator=L,\n        target_state=reshape(ρ̂₂_tgt, :),\n        weight=weights[2]\n    ),\n    Objective(\n        initial_state=reshape(ρ̂₃, :),\n        generator=L,\n        target_state=reshape(ρ̂₃_tgt, :),\n        weight=weights[3]\n    )\n];\nnothing #hide","category":"page"},{"location":"examples/rho_3states/#Dynamics-under-the-Guess-Pulse","page":"Example 2 (Diss. Gate)","title":"Dynamics under the Guess Pulse","text":"","category":"section"},{"location":"examples/rho_3states/","page":"Example 2 (Diss. Gate)","title":"Example 2 (Diss. Gate)","text":"ρ̂₀₀ = ket(0, 0) * adjoint(ket(0, 0));\nρ̂₀₁ = ket(0, 1) * adjoint(ket(0, 1));\nρ̂₁₀ = ket(1, 0) * adjoint(ket(1, 0));\nρ̂₁₁ = ket(1, 1) * adjoint(ket(1, 1));\n\nfunction as_matrix(ρ⃗)\n    N = isqrt(length(ρ⃗))\n    return reshape(ρ⃗, N, N)\nend;\n\npop00 = ρ⃗ -> real(tr(as_matrix(ρ⃗) * ρ̂₀₀));\npop01 = ρ⃗ -> real(tr(as_matrix(ρ⃗) * ρ̂₀₁));\npop10 = ρ⃗ -> real(tr(as_matrix(ρ⃗) * ρ̂₁₀));\npop11 = ρ⃗ -> real(tr(as_matrix(ρ⃗) * ρ̂₁₁));\n\n\nrho_00_expvals = propagate_objective(\n    objectives[1],\n    tlist;\n    initial_state=reshape(ρ̂₀₀, :),\n    method=:newton,\n    observables=(pop00, pop01, pop10, pop11),\n    storage=true\n);\nnothing #hide","category":"page"},{"location":"examples/rho_3states/#Optimization","page":"Example 2 (Diss. Gate)","title":"Optimization","text":"","category":"section"},{"location":"examples/rho_3states/","page":"Example 2 (Diss. Gate)","title":"Example 2 (Diss. Gate)","text":"const problem = ControlProblem(\n    objectives=objectives,\n    prop_method=:newton,\n    use_threads=true,\n    lambda_a=1.0,\n    update_shape=(t -> QuantumControl.Shapes.flattop(t, T=T, t_rise=20ns, func=:blackman)),\n    tlist=tlist,\n    iter_stop=3000,\n    J_T=QuantumControl.Functionals.J_T_re,\n    check_convergence=res -> begin\n        ((res.J_T < 1e-3) && (res.converged = true) && (res.message = \"J_T < 10⁻³\"))\n    end\n);\nnothing #hide","category":"page"},{"location":"examples/rho_3states/","page":"Example 2 (Diss. Gate)","title":"Example 2 (Diss. Gate)","text":"opt_result = @optimize_or_load(\n    datadir(\"DissGateOCT#J_T=J_T_re#iter_stop=3000#method=krotov.jld2\"),\n    problem,\n    method = :krotov\n)","category":"page"},{"location":"examples/rho_3states/","page":"Example 2 (Diss. Gate)","title":"Example 2 (Diss. Gate)","text":"opt_result","category":"page"},{"location":"examples/rho_3states/#Optimization-result","page":"Example 2 (Diss. Gate)","title":"Optimization result","text":"","category":"section"},{"location":"examples/rho_3states/","page":"Example 2 (Diss. Gate)","title":"Example 2 (Diss. Gate)","text":"","category":"page"},{"location":"examples/rho_3states/","page":"Example 2 (Diss. Gate)","title":"Example 2 (Diss. Gate)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [Krotov]","category":"page"},{"location":"api/#Krotov.KrotovResult","page":"API","title":"Krotov.KrotovResult","text":"Result object returned by optimize_krotov.\n\n\n\n\n\n","category":"type"},{"location":"api/#Krotov.optimize_krotov-Tuple{Any}","page":"API","title":"Krotov.optimize_krotov","text":"See optimize(problem; method=:krotov, kwargs...).\n\n\n\n\n\n","category":"method"},{"location":"api/#Krotov.print_table-Tuple{Any, Any, Vararg{Any}}","page":"API","title":"Krotov.print_table","text":"Print optimization progress as a table.\n\nThis functions serves as the default info_hook for an optimization with Krotov's method.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumControlBase.optimize-Tuple{Any, Val{:krotov}}","page":"API","title":"QuantumControlBase.optimize","text":"result = optimize(problem; method=:krotov, kwargs...)\n\noptimizes the given control problem using Krotov's method, returning a KrotovResult.\n\nKeyword arguments that control the optimization are taken from the keyword arguments used in the instantiation of problem.\n\nRequired problem keyword arguments\n\nJ_T: A function J_T(ϕ, objectives) that evaluates the final time functional from a list ϕ of forward-propagated states and problem.objectives.\n\nRecommended problem keyword arguments\n\nlambda_a=1.0: The inverse Krotov step width λ_a for every pulse.\nupdate_shape=(t->1.0): A function S(t) for the \"update shape\" that scales the update for every pulse\n\nIf different controls require different lambda_a or update_shape, a dict pulse_options must be given instead of a global lambda_a and update_shape, see below.\n\nOptional problem keyword arguments\n\nThe following keyword arguments are supported (with default values):\n\npulse_options: A dictionary that maps every control (as obtained by get_controls from the problem.objectives) to the following dict:\n:lambda_a:  The value for inverse Krotov step width λₐ\n:update_shape: A function S(t) for the \"update shape\" that scales the Krotov pulse update.\nThis overrides the global lambda_a and update_shape arguments.\nchi: A function chi!(χ, ϕ, objectives) what receives a list ϕ of the forward propagated states and must set χₖ = -J_Tϕₖ. If not given, it will be automatically determined from J_T via make_chi with the default parameters.\nsigma=nothing: Function that calculate the second-order contribution. If not given, the first-order Krotov method is used.\niter_start=0: the initial iteration number\niter_stop=5000: the maximum iteration number\nprop_method/fw_prop_method/bw_prop_method: The propagation method to use for each objective, see below.\nupdate_hook: A function that receives the Krotov workspace, the iteration number, the list of updated pulses and the list of guess pulses as positional arguments. The function may mutate any of its arguments. This may be used e.g. to apply a spectral filter to the updated pulses, or to update propagation workspaces inside the Krotov workspace.\ninfo_hook: A function (or tuple of functions) that receives the same argumens as update_hook, in order to write information about the current iteration to the screen or to a file. The default info_hook prints a table with convergence information to the screen. Runs after update_hook. The info_hook function may return a tuple, which is stored in the list of records inside the KrotovResult object.\ncheck_convergence: a function to check whether convergence has been reached. Receives a KrotovResult object result, and should set result.converged to true and result.message to an appropriate string in case of convergence. Multiple convergence checks can be performed by chaining functions with ∘. The convergence check is performed after any calls to update_hook and info_hook.\nverbose=false: If true, print information during initialization\n\nThe propagation method for the forward propagation of each objective is determined by the first available item of the following:\n\na fw_prop_method keyword argument\na prop_method keyword argument\na property fw_prop_method of the objective\na property prop_method of the objective\nthe value :auto\n\nThe propagation method for the backword propagation is determined similarly, but with bw_prop_method instead of fw_prop_method.\n\n\n\n\n\n","category":"method"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"EditURL = \"https://github.com/JuliaQuantumControl/Krotov.jl/blob/master/examples/state_to_state_parametrizations.jl\"","category":"page"},{"location":"examples/state_to_state_parametrizations/#Example-3:-Pulse-Parametrization","page":"Example 3 (Parametrization)","title":"Example 3: Pulse Parametrization","text":"","category":"section"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"tip: Tip\nThis example is also available as a Jupyter notebook: state_to_state_parametrizations.ipynb.","category":"page"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"gdefop1hat1 gdefinittextinit gdeftgttexttgt","category":"page"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"This example illustrates the parametrization of control pulses as a form of amplitude constraint.","category":"page"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"using DrWatson\n@quickactivate \"KrotovTests\"","category":"page"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"using QuantumControl\nusing QuantumControl.Shapes: flattop\nusing QuantumControl.Generators\nusing QuantumControl.Controls\nusing QuantumControl.PulseParametrizations:\n    SquareParametrization,\n    TanhParametrization,\n    TanhSqParametrization,\n    LogisticParametrization,\n    LogisticSqParametrization,\n    ParametrizedAmplitude\nusing LinearAlgebra","category":"page"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"using Plots\nPlots.default(\n    linewidth               = 3,\n    size                    = (550, 300),\n    legend                  = :top,\n    foreground_color_legend = nothing,\n    background_color_legend = RGBA(1, 1, 1, 0.8),\n)","category":"page"},{"location":"examples/state_to_state_parametrizations/#Parametrizations","page":"Example 3 (Parametrization)","title":"Parametrizations","text":"","category":"section"},{"location":"examples/state_to_state_parametrizations/#Symmetric-Bounded-Controls","page":"Example 3 (Parametrization)","title":"Symmetric Bounded Controls","text":"","category":"section"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"include(joinpath(@__DIR__, \"plots\", \"symmetric_parametrization_comparison.jl\"))  # hide\nfig = plot_symmetric_parametrization_comparison()  # hide","category":"page"},{"location":"examples/state_to_state_parametrizations/#Positive-(Bounded)-Controls","page":"Example 3 (Parametrization)","title":"Positive (Bounded) Controls","text":"","category":"section"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"include(joinpath(@__DIR__, \"plots\", \"positive_parametrization_comparison.jl\"))  # hide\nfig = plot_positive_parametrization_comparison()  # hide","category":"page"},{"location":"examples/state_to_state_parametrizations/#Two-level-Hamiltonian","page":"Example 3 (Parametrization)","title":"Two-level Hamiltonian","text":"","category":"section"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"We consider the Hamiltonian opH_0 = - fracomega2 opsigma_z, representing a simple qubit with energy level splitting omega in the basis ket0ket1. The control field epsilon(t) is assumed to couple via the Hamiltonian opH_1(t) = epsilon(t) opsigma_x to the qubit, i.e., the control field effectively drives transitions between both qubit states.","category":"page"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"We we will use","category":"page"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"ϵ(t) = 0.2 * flattop(t, T=5, t_rise=0.3, func=:blackman);\nnothing #hide","category":"page"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"\"\"\"Two-level-system Hamiltonian.\"\"\"\nfunction tls_hamiltonian(; Ω=1.0, ampl=ϵ)\n    σ̂_z = ComplexF64[\n        1  0\n        0 -1\n    ]\n    σ̂_x = ComplexF64[\n        0  1\n        1  0\n    ]\n    Ĥ₀ = -0.5 * Ω * σ̂_z\n    Ĥ₁ = σ̂_x\n    return hamiltonian(Ĥ₀, (Ĥ₁, ampl))\nend;\nnothing #hide","category":"page"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"H = tls_hamiltonian();\nnothing #hide","category":"page"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"The control field here switches on from zero at t=0 to it's maximum amplitude 0.2 within the time period 0.3 (the switch-on shape is half a Blackman pulse). It switches off again in the time period 0.3 before the final time T=5). We use a time grid with 500 time steps between 0 and T:","category":"page"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"tlist = collect(range(0, 5, length=500));\nnothing #hide","category":"page"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"function plot_amplitude(ampl, tlist)\n    plot(tlist, discretize(ampl, tlist), xlabel=\"time\", ylabel=\"amplitude\", legend=false)\nend\n\nplot_amplitude(ϵ, tlist)","category":"page"},{"location":"examples/state_to_state_parametrizations/#Optimization-target","page":"Example 3 (Parametrization)","title":"Optimization target","text":"","category":"section"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"The krotov package requires the goal of the optimization to be described by a list of Objective instances. In this example, there is only a single objective: the state-to-state transfer from initial state ketPsi_init = ket0 to the target state ketPsi_tgt = ket1, under the dynamics of the Hamiltonian opH(t):","category":"page"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"function ket(label)\n    result = Dict(\"0\" => Vector{ComplexF64}([1, 0]), \"1\" => Vector{ComplexF64}([0, 1]),)\n    return result[string(label)]\nend;\nnothing #hide","category":"page"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"objectives = [Objective(initial_state=ket(0), generator=H, target_state=ket(1))]","category":"page"},{"location":"examples/state_to_state_parametrizations/#Square-parametrization-for-positive-pulses","page":"Example 3 (Parametrization)","title":"Square-parametrization for positive pulses","text":"","category":"section"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"a = ParametrizedAmplitude(\n    ϵ,\n    tlist;\n    parametrization=SquareParametrization(),\n    parameterize=true\n)","category":"page"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"function plot_amplitude(ampl::ParametrizedAmplitude, tlist)\n    plot(\n        tlist,\n        discretize(Array(ampl), tlist),\n        xlabel=\"time\",\n        ylabel=\"amplitude\",\n        legend=false\n    )\nend\n\nplot_amplitude(a, tlist)","category":"page"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"problem = ControlProblem(\n    objectives=substitute(objectives, IdDict(ϵ => a)),\n    lambda_a=5,\n    update_shape=(t -> flattop(t, T=5, t_rise=0.3, func=:blackman)),\n    tlist=tlist,\n    iter_stop=50,\n    J_T=QuantumControl.Functionals.J_T_ss,\n    check_convergence=res -> begin\n        ((res.J_T < 1e-3) && (res.converged = true) && (res.message = \"J_T < 10⁻³\"))\n    end\n);\nnothing #hide","category":"page"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"opt_result_positive = @optimize_or_load(\n    datadir(\"parametrization#opt_result_positive.jld2\"),\n    problem;\n    method=:krotov\n);\nnothing #hide","category":"page"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"opt_result_positive","category":"page"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"We can plot the optimized field:","category":"page"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"plot_amplitude(\n    substitute(a, IdDict(a.control => opt_result_positive.optimized_controls[1])),\n    tlist\n)","category":"page"},{"location":"examples/state_to_state_parametrizations/#Tanh-Square-Parametrization-for-positive-amplitude-constrained-pulses","page":"Example 3 (Parametrization)","title":"Tanh-Square-Parametrization for positive amplitude-constrained pulses","text":"","category":"section"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"a = ParametrizedAmplitude(\n    ϵ,\n    tlist;\n    parametrization=TanhSqParametrization(3),\n    parameterize=true\n)\n\nproblem_tanhsq = ControlProblem(\n    objectives=substitute(objectives, IdDict(ϵ => a)),\n    lambda_a=10,\n    update_shape=(t -> flattop(t, T=5, t_rise=0.3, func=:blackman)),\n    tlist=tlist,\n    iter_stop=50,\n    J_T=QuantumControl.Functionals.J_T_ss,\n    check_convergence=res -> begin\n        ((res.J_T < 1e-3) && (res.converged = true) && (res.message = \"J_T < 10⁻³\"))\n    end\n);\nnothing #hide","category":"page"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"opt_result_tanhsq = @optimize_or_load(\n    datadir(\"parametrization#opt_result_tanhsq.jld2\"),\n    problem_tanhsq;\n    method=:krotov\n);\nnothing #hide","category":"page"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"opt_result_tanhsq","category":"page"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"We can plot the optimized field:","category":"page"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"plot_amplitude(\n    substitute(a, IdDict(a.control => opt_result_tanhsq.optimized_controls[1])),\n    tlist\n)","category":"page"},{"location":"examples/state_to_state_parametrizations/#Logistic-Square-Parametrization-for-positive-amplitude-constrained-pulses","page":"Example 3 (Parametrization)","title":"Logistic-Square-Parametrization for positive amplitude-constrained pulses","text":"","category":"section"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"a = ParametrizedAmplitude(\n    ϵ,\n    tlist;\n    parametrization=LogisticSqParametrization(3, k=1.0),\n    parameterize=true\n)\n\nproblem_logisticsq = ControlProblem(\n    objectives=substitute(objectives, IdDict(ϵ => a)),\n    lambda_a=1,\n    update_shape=(t -> flattop(t, T=5, t_rise=0.3, func=:blackman)),\n    tlist=tlist,\n    iter_stop=50,\n    J_T=QuantumControl.Functionals.J_T_ss,\n    check_convergence=res -> begin\n        ((res.J_T < 1e-3) && (res.converged = true) && (res.message = \"J_T < 10⁻³\"))\n    end\n);\nnothing #hide","category":"page"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"opt_result_logisticsq = @optimize_or_load(\n    datadir(\"parametrization#opt_result_logisticsq.jld2\"),\n    problem_logisticsq;\n    method=:krotov\n);\nnothing #hide","category":"page"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"We can plot the optimized field:","category":"page"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"plot_amplitude(\n    substitute(a, IdDict(a.control => opt_result_logisticsq.optimized_controls[1])),\n    tlist\n)","category":"page"},{"location":"examples/state_to_state_parametrizations/#Tanh-parametrization-for-amplitude-constrained-pulses","page":"Example 3 (Parametrization)","title":"Tanh-parametrization for amplitude-constrained pulses","text":"","category":"section"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"a = ParametrizedAmplitude(\n    ϵ,\n    tlist;\n    parametrization=TanhParametrization(-0.5, 0.5),\n    parameterize=true\n)\n\nproblem_tanh = ControlProblem(\n    objectives=substitute(objectives, IdDict(ϵ => a)),\n    lambda_a=1,\n    update_shape=(t -> flattop(t, T=5, t_rise=0.3, func=:blackman)),\n    tlist=tlist,\n    iter_stop=50,\n    J_T=QuantumControl.Functionals.J_T_ss,\n    check_convergence=res -> begin\n        ((res.J_T < 1e-3) && (res.converged = true) && (res.message = \"J_T < 10⁻³\"))\n    end\n);\nnothing #hide","category":"page"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"opt_result_tanh = @optimize_or_load(\n    datadir(\"parametrization#opt_result_tanh.jld2\"),\n    problem_tanh;\n    method=:krotov\n);\nnothing #hide","category":"page"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"plot_amplitude(\n    substitute(a, IdDict(a.control => opt_result_tanh.optimized_controls[1])),\n    tlist\n)","category":"page"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"","category":"page"},{"location":"examples/state_to_state_parametrizations/","page":"Example 3 (Parametrization)","title":"Example 3 (Parametrization)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"EditURL = \"https://github.com/JuliaQuantumControl/Krotov.jl/blob/master/examples/perfect_entanglers.jl\"","category":"page"},{"location":"examples/perfect_entanglers/#Example-4:-Optimization-for-a-perfect-entangler","page":"Example 4 (PE)","title":"Example 4: Optimization for a perfect entangler","text":"","category":"section"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"tip: Tip\nThis example is also available as a Jupyter notebook: perfect_entanglers.ipynb.Compare this example against the same example using GRAPE.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"gdefop1hat1 gdefinittextinit gdeftgttexttgt","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"using DrWatson\n@quickactivate \"KrotovTests\"","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"This example illustrates the optimization towards a perfectly entangling two-qubit gate for a system of two transmon qubits with a shared transmission line. It uses both the indirect perfect entanglers functional shown in Goerz et al., Phys. Rev. A 91, 062307 (2015) [1]  and a direct maximization of the gate concurrence and thus demonstrates the optimization for non-analytic functions via the calculation of gradients with automatic differentiation.","category":"page"},{"location":"examples/perfect_entanglers/#Hamiltonian-and-guess-pulses","page":"Example 4 (PE)","title":"Hamiltonian and guess pulses","text":"","category":"section"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"We will write the Hamiltonian in units of GHz (angular frequency; the factor 2π is implicit) and ns:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"const GHz = 2π\nconst MHz = 0.001GHz\nconst ns = 1.0\nconst μs = 1000ns;\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"The Hamiltonian and parameters are taken from Ref. [1, Table 1].","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"⊗ = kron\nconst 𝕚 = 1im\nconst N = 6  # levels per transmon\n\nusing LinearAlgebra\nusing SparseArrays\nusing QuantumControl\n\n\nfunction transmon_hamiltonian(;\n    Ωre,\n    Ωim,\n    N=N,  # levels per transmon\n    ω₁=4.380GHz,\n    ω₂=4.614GHz,\n    ωd=4.498GHz,\n    α₁=-210MHz,\n    α₂=-215MHz,\n    J=-3MHz,\n    λ=1.03,\n    use_sparse=:auto\n)\n    𝟙 = SparseMatrixCSC{ComplexF64,Int64}(sparse(I, N, N))\n    b̂₁ = spdiagm(1 => complex.(sqrt.(collect(1:N-1)))) ⊗ 𝟙\n    b̂₂ = 𝟙 ⊗ spdiagm(1 => complex.(sqrt.(collect(1:N-1))))\n    b̂₁⁺ = sparse(b̂₁')\n    b̂₂⁺ = sparse(b̂₂')\n    n̂₁ = sparse(b̂₁' * b̂₁)\n    n̂₂ = sparse(b̂₂' * b̂₂)\n    n̂₁² = sparse(n̂₁ * n̂₁)\n    n̂₂² = sparse(n̂₂ * n̂₂)\n    b̂₁⁺_b̂₂ = sparse(b̂₁' * b̂₂)\n    b̂₁_b̂₂⁺ = sparse(b̂₁ * b̂₂')\n\n    ω̃₁ = ω₁ - ωd\n    ω̃₂ = ω₂ - ωd\n\n    Ĥ₀ = sparse(\n        (ω̃₁ - α₁ / 2) * n̂₁ +\n        (α₁ / 2) * n̂₁² +\n        (ω̃₂ - α₂ / 2) * n̂₂ +\n        (α₂ / 2) * n̂₂² +\n        J * (b̂₁⁺_b̂₂ + b̂₁_b̂₂⁺)\n    )\n\n    Ĥ₁re = (1 / 2) * (b̂₁ + b̂₁⁺ + λ * b̂₂ + λ * b̂₂⁺)\n    Ĥ₁im = (𝕚 / 2) * (b̂₁⁺ - b̂₁ + λ * b̂₂⁺ - λ * b̂₂)\n\n    if ((N < 5) && (use_sparse ≢ true)) || use_sparse ≡ false\n        H = hamiltonian(Array(Ĥ₀), (Array(Ĥ₁re), Ωre), (Array(Ĥ₁im), Ωim))\n    else\n        H = hamiltonian(Ĥ₀, (Ĥ₁re, Ωre), (Ĥ₁im, Ωim))\n    end\n    return H\n\nend;\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"We choose a pulse duration of 400 ns. The guess pulse amplitude is 35 MHz, with a 15 ns switch-on/-off time. The Hamiltonian is written in a rotating frame, so in general, the control field is allowed to be complex-valued. We separate this into two control fields, one for the real part and one for the imaginary part. Initially, the imaginary part is zero, corresponding to a field exactly at the frequency of the rotating frame.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"using QuantumControl.Shapes: flattop\n\nfunction guess_pulses(; T=400ns, E₀=35MHz, dt=0.1ns, t_rise=15ns)\n\n    tlist = collect(range(0, T, step=dt))\n    Ωre = t -> E₀ * flattop(t, T=T, t_rise=t_rise)\n    Ωim = t -> 0.0\n\n    return tlist, Ωre, Ωim\n\nend\n\ntlist, Ωre_guess, Ωim_guess = guess_pulses();\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"We can visualize this:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"using Plots\nPlots.default(\n    linewidth               = 3,\n    size                    = (550, 300),\n    legend                  = :right,\n    foreground_color_legend = nothing,\n    background_color_legend = RGBA(1, 1, 1, 0.8),\n)\n\nfunction plot_complex_pulse(tlist, Ω; time_unit=:ns, ampl_unit=:MHz, kwargs...)\n\n    ax1 = plot(\n        tlist ./ eval(time_unit),\n        abs.(Ω) ./ eval(ampl_unit);\n        label=\"|Ω|\",\n        xlabel=\"time ($time_unit)\",\n        ylabel=\"amplitude ($ampl_unit)\",\n        kwargs...\n    )\n\n    ax2 = plot(\n        tlist ./ eval(time_unit),\n        angle.(Ω) ./ π;\n        label=\"ϕ(Ω)\",\n        xlabel=\"time ($time_unit)\",\n        ylabel=\"phase (π)\"\n    )\n\n    plot(ax1, ax2, layout=(2, 1))\n\nend\n\nplot_complex_pulse(tlist, Ωre_guess.(tlist) + 𝕚 * Ωim_guess.(tlist))","category":"page"},{"location":"examples/perfect_entanglers/#Logical-basis-for-two-qubit-gates","page":"Example 4 (PE)","title":"Logical basis for two-qubit gates","text":"","category":"section"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"For simplicity, we will be define the qubits in the bare basis, i.e. ignoring the static coupling J.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"function ket(i::Int64; N=N)\n    Ψ = zeros(ComplexF64, N)\n    Ψ[i+1] = 1\n    return Ψ\nend\n\nfunction ket(indices::Int64...; N=N)\n    Ψ = ket(indices[1]; N=N)\n    for i in indices[2:end]\n        Ψ = Ψ ⊗ ket(i; N=N)\n    end\n    return Ψ\nend\n\nfunction ket(label::AbstractString; N=N)\n    indices = [parse(Int64, digit) for digit in label]\n    return ket(indices...; N=N)\nend\n\nbasis = [ket(\"00\"), ket(\"01\"), ket(\"10\"), ket(\"11\")];\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/#Defining-the-optimization-problem","page":"Example 4 (PE)","title":"Defining the optimization problem","text":"","category":"section"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"We define the optimization with one objective for each of the four basis states:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"H = transmon_hamiltonian(Ωre=Ωre_guess, Ωim=Ωim_guess);\n\nobjectives = [Objective(; initial_state=Ψ, generator=H) for Ψ ∈ basis];\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"Note that we omit the target_state here. This is because we will be optimizing for an arbitrary perfect entangler, not for a specific quantum gate. Thus, there is no a-priori known target state to which the initial state must evolve.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"The optimization is steered by the perfect entanglers distance measure D_PE, that is, the geometric distance of the quantum gate obtained from propagating the four basis states to the polyhedron of perfect entanglers in the Weyl chamber. Since the logical subspace defining the qubit is embedded in the larger Hilbert space of the transmon, there may be loss of population from the logical subspace. To counter this possibility in the optimization, we add a unitarity measure  to D_PE. The two terms are added with equal weight.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"using TwoQubitWeylChamber: D_PE, gate_concurrence, unitarity\nusing QuantumControl.Functionals: gate_functional\n\nJ_T_PE = gate_functional(D_PE; unitarity_weight=0.5);\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"The gate_functional routines used above converts the function D_PE that receives the gate U as a 4×4 matrix into a functional of the correct from for the QuantumControl.optimize routine, which is a function of the propagated states.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"We can check that for the guess pulse, we are not implementing a perfect entangler","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"using QuantumControl: propagate_objectives\n\nguess_states = propagate_objectives(objectives, tlist; use_threads=true);\n\nU_guess = [basis[i] ⋅ guess_states[j] for i = 1:4, j = 1:4]\n\ngate_concurrence(U_guess)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"We find that the guess pulse produces a gate in the W0* region of the Weyl chamber:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"using TwoQubitWeylChamber: weyl_chamber_region\nweyl_chamber_region(U_guess)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"That is, the region of the Weyl chamber containing controlled-phase gates with a phase  π (Weyl chamber coordinates c₁  π2, c₂  π4).","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"This in fact allows use to use the perfect entangler functional without modification: if the guess pulse were in the \"W1\" region of the Weyl chamber, (close to SWAP), we would have to flip its sign, or we would optimize towards the local equivalence class of the SWAP gate instead of towards the perfect of perfect entanglers. In principle, we could use a modified functional that takes the absolute square of the D_PE term, by using","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"J_T_PE = gate_functional(D_PE; unitarity_weight=0.5, absolute_square=true)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"This would specifically optimize for the surface of the perfect entanglers functional.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"The guess pulse loses about 10% of population from the logical subspace:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"1 - unitarity(U_guess)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"We can also evaluate the geometric distance to the polyhedron of perfect entanglers in the Weyl chamber:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"D_PE(U_guess)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"Together with the unitarity measure, this is the initial value of the optimization functional:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"0.5 * D_PE(U_guess) + 0.5 * (1 - unitarity(U_guess))","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"J_T_PE(guess_states, objectives)","category":"page"},{"location":"examples/perfect_entanglers/#Optimization","page":"Example 4 (PE)","title":"Optimization","text":"","category":"section"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"Now, we formulate the full control problem","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"problem = ControlProblem(\n    objectives=objectives,\n    lambda_a=10.0,\n    update_shape=(t -> flattop(t, T=400ns, t_rise=15ns, func=:blackman)),\n    tlist=tlist,\n    iter_stop=100,\n    J_T=J_T_PE,\n    check_convergence=res -> begin\n        (\n            (res.J_T > res.J_T_prev) &&\n            (res.converged = true) &&\n            (res.message = \"Loss of monotonic convergence\")\n        )\n        (\n            (res.J_T <= 1e-3) &&\n            (res.converged = true) &&\n            (res.message = \"Found a perfect entangler\")\n        )\n    end,\n    use_threads=true,\n);\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"Note that we have not not given a chi parameter to calculate the boundary condition χₖ = -J_Tϕₖ that Krotov's method requires. In this case, the Krotov.jl package will use automatic differentiation to determine the derivative. In principle, the perfect entanglers function has an analytical derivative, but it is exceedingly laborious to calculate and implement it (see the source code of the weylchamber Python package, which can evaluate that derivative).","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"opt_result = @optimize_or_load(datadir(\"PE_OCT.jld2\"), problem; method=:Krotov);\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"opt_result","category":"page"},{"location":"examples/perfect_entanglers/#Optimization-result","page":"Example 4 (PE)","title":"Optimization result","text":"","category":"section"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"We extract the optimized control field from the optimization result and plot it","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"Ω_opt = opt_result.optimized_controls[1] + 𝕚 * opt_result.optimized_controls[2]\n\nplot_complex_pulse(tlist, Ω_opt)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"We then propagate the optimized control field to analyze the resulting quantum gate:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"using QuantumControl.Controls: substitute, get_controls\n\nopt_states = propagate_objectives(\n    substitute(\n        objectives,\n        IdDict(zip(get_controls(objectives), opt_result.optimized_controls))\n    ),\n    tlist;\n    use_threads=true\n);\n\nU_opt = [basis[i] ⋅ opt_states[j] for i = 1:4, j = 1:4];\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"We find that we have achieved a perfect entangler:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"gate_concurrence(U_opt)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"Moreover, we have reduced the population loss to ≈ 1%","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"1 - unitarity(U_opt)","category":"page"},{"location":"examples/perfect_entanglers/#Direct-maximization-of-the-gate-concurrence","page":"Example 4 (PE)","title":"Direct maximization of the gate concurrence","text":"","category":"section"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"In the previous optimizations, we have optimized for a perfect entangler indirectly via a geometric function in the Weyl chamber. The entire reason that perfect entangler functional was formulated is because calculating the gate concurrence directly involves the eigenvalues of the unitary, see Kraus and Cirac [2] and Childs et al. [3], which are inherently non-analytic.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"However, since Krotov.jl can use automatic differentiation, this is no longer an insurmountable obstacle!","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"We can define a functional for a given gate U that combines the gate concurrence and (as above) a unitarity measure to penalize loss of population from the logical subspace:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"J_T_C = U -> 0.5 * (1 - gate_concurrence(U)) + 0.5 * (1 - unitarity(U));\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"In the optimization, we will convert this functional to one that takes the propagated states as arguments (via the gate_functional routine). We can do that same for the gradient: Let Zygote (the automatic differentiation framework we are using) determine the gradient for J_T_C with respect to U, but then analytically translate that into the derivative with respect to the states that we need to calculate the χ-states.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"using QuantumControl.Functionals: make_gate_chi\n\nchi_C = make_gate_chi(J_T_C, objectives);\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"Running this, we again are able to find a perfect entangler.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"opt_result_direct = @optimize_or_load(\n    datadir(\"PE_OCT_direct.jld2\"),\n    problem;\n    method=:Krotov,\n    J_T=gate_functional(J_T_C),\n    chi=chi_C\n);\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"opt_result_direct","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"opt_states_direct = propagate_objectives(\n    substitute(\n        objectives,\n        IdDict(zip(get_controls(objectives), opt_result_direct.optimized_controls))\n    ),\n    tlist;\n    use_threads=true\n);\n\nU_opt_direct = [basis[i] ⋅ opt_states_direct[j] for i = 1:4, j = 1:4];\nnothing #hide","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"gate_concurrence(U_opt_direct)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"1 - unitarity(U_opt_direct)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"","category":"page"},{"location":"examples/perfect_entanglers/","page":"Example 4 (PE)","title":"Example 4 (PE)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/#Examples","page":"List of Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"List of Examples","title":"List of Examples","text":"Pages = [\n    \"simple_state_to_state.md\",\n    \"state_to_state_rwa.md\",\n    \"rho_3states.md\",\n    \"state_to_state_parametrizations.md\",\n    \"perfect_entanglers.md\",\n]\nDepth = 1","category":"page"},{"location":"examples/","page":"List of Examples","title":"List of Examples","text":"See also the general examples of the QuantumControl package.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"EditURL = \"https://github.com/JuliaQuantumControl/Krotov.jl/blob/master/examples/simple_state_to_state.jl\"","category":"page"},{"location":"examples/simple_state_to_state/#Example-1:-Optimization-of-a-State-to-State-Transfer-in-a-Two-Level-System","page":"Example 1 (TLS)","title":"Example 1: Optimization of a State-to-State Transfer in a Two-Level-System","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"tip: Tip\nThis example is also available as a Jupyter notebook: simple_state_to_state.ipynb.Compare this example against the same example using the krotov Python package.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"gdefop1hat1 gdefinittextinit gdeftgttexttgt","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"This first example illustrates the basic use of the Krotov.jl by solving a simple canonical optimization problem: the transfer of population in a two level system.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"using DrWatson\n@quickactivate \"KrotovTests\"","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"using QuantumControl\nusing QuantumPropagators.Controls: substitute\nusing LinearAlgebra","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"using Plots\nPlots.default(\n    linewidth               = 3,\n    size                    = (550, 300),\n    legend                  = :right,\n    foreground_color_legend = nothing,\n    background_color_legend = RGBA(1, 1, 1, 0.8),\n)","category":"page"},{"location":"examples/simple_state_to_state/#Two-level-Hamiltonian","page":"Example 1 (TLS)","title":"Two-level Hamiltonian","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"We consider the Hamiltonian opH_0 = - fracomega2 opsigma_z, representing a simple qubit with energy level splitting omega in the basis ket0ket1. The control field epsilon(t) is assumed to couple via the Hamiltonian opH_1(t) = epsilon(t) opsigma_x to the qubit, i.e., the control field effectively drives transitions between both qubit states.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"We we will use","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"ϵ(t) = 0.2 * QuantumControl.Shapes.flattop(t, T=5, t_rise=0.3, func=:blackman);\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"\"\"\"Two-level-system Hamiltonian.\"\"\"\nfunction tls_hamiltonian(Ω=1.0, ϵ=ϵ)\n    σ̂_z = ComplexF64[\n        1  0\n        0 -1\n    ]\n    σ̂_x = ComplexF64[\n        0  1\n        1  0\n    ]\n    Ĥ₀ = -0.5 * Ω * σ̂_z\n    Ĥ₁ = σ̂_x\n    return hamiltonian(Ĥ₀, (Ĥ₁, ϵ))\nend;\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"H = tls_hamiltonian();\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"The control field here switches on from zero at t=0 to it's maximum amplitude 0.2 within the time period 0.3 (the switch-on shape is half a Blackman pulse). It switches off again in the time period 0.3 before the final time T=5). We use a time grid with 500 time steps between 0 and T:","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"tlist = collect(range(0, 5, length=500));\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"function plot_control(pulse::Vector, tlist)\n    plot(tlist, pulse, xlabel=\"time\", ylabel=\"amplitude\", legend=false)\nend\n\nplot_control(ϵ::T, tlist) where {T<:Function} = plot_control([ϵ(t) for t in tlist], tlist);\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"fig = plot_control(ϵ, tlist)","category":"page"},{"location":"examples/simple_state_to_state/#Optimization-target","page":"Example 1 (TLS)","title":"Optimization target","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"The krotov package requires the goal of the optimization to be described by a list of Objective instances. In this example, there is only a single objective: the state-to-state transfer from initial state ketPsi_init = ket0 to the target state ketPsi_tgt = ket1, under the dynamics of the Hamiltonian opH(t):","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"function ket(label)\n    result = Dict(\"0\" => Vector{ComplexF64}([1, 0]), \"1\" => Vector{ComplexF64}([0, 1]),)\n    return result[string(label)]\nend;\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"objectives = [Objective(initial_state=ket(0), generator=H, target_state=ket(1))]","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"problem = ControlProblem(\n    objectives=objectives,\n    lambda_a=5,\n    update_shape=(t -> QuantumControl.Shapes.flattop(t, T=5, t_rise=0.3, func=:blackman)),\n    tlist=tlist,\n    iter_stop=50,\n    J_T=QuantumControl.Functionals.J_T_ss,\n    check_convergence=res -> begin\n        ((res.J_T < 1e-3) && (res.converged = true) && (res.message = \"J_T < 10⁻³\"))\n    end\n);\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/#Simulate-dynamics-under-the-guess-field","page":"Example 1 (TLS)","title":"Simulate dynamics under the guess field","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"Before running the optimization procedure, we first simulate the dynamics under the guess field epsilon_0(t). The following solves equation of motion for the defined objective, which contains the initial state ketPsi_init and the Hamiltonian opH(t) defining its evolution.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"guess_dynamics = propagate_objective(\n    objectives[1],\n    problem.tlist;\n    storage=true,\n    observables=(Ψ -> abs.(Ψ) .^ 2,)\n)","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"function plot_population(pop0::Vector, pop1::Vector, tlist)\n    fig = plot(tlist, pop0, label=\"0\", xlabel=\"time\", ylabel=\"population\")\n    plot!(fig, tlist, pop1; label=\"1\")\nend;\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"fig = plot_population(guess_dynamics[1, :], guess_dynamics[2, :], tlist)","category":"page"},{"location":"examples/simple_state_to_state/#Optimize","page":"Example 1 (TLS)","title":"Optimize","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"In the following we optimize the guess field epsilon_0(t) such that the intended state-to-state transfer ketPsi_init rightarrow ketPsi_tgt is solved, via optimize routine. It requires, besides the previously defined objectives, information about the optimization functional J_T.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"opt_result = @optimize_or_load(\n    datadir(\"TLSOCT#J_T=J_T_ss#iter_stop=50#method=krotov.jld2\"),\n    problem,\n    method = :krotov,\n);\nnothing #hide","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"opt_result","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"We can plot the optimized field:","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"fig = plot_control(opt_result.optimized_controls[1], tlist)","category":"page"},{"location":"examples/simple_state_to_state/#Simulate-the-dynamics-under-the-optimized-field","page":"Example 1 (TLS)","title":"Simulate the dynamics under the optimized field","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"Having obtained the optimized control field, we can simulate the dynamics to verify that the optimized field indeed drives the initial state ketPsi_init = ket0 to the desired target state ketPsi_tgt = ket1.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"opt_dynamics = propagate_objective(\n    substitute(objectives[1], IdDict(ϵ => opt_result.optimized_controls[1])),\n    problem.tlist;\n    storage=true,\n    observables=(Ψ -> abs.(Ψ) .^ 2,)\n)","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"fig = plot_population(opt_dynamics[1, :], opt_dynamics[2, :], tlist)","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"","category":"page"},{"location":"examples/simple_state_to_state/","page":"Example 1 (TLS)","title":"Example 1 (TLS)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Krotov","category":"page"},{"location":"#Krotov.jl","page":"Home","title":"Krotov.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Markdown\nusing Pkg\n\nVERSION = Pkg.dependencies()[Base.UUID(\"b05dcdc7-62f6-4360-bf2c-0898bba419de\")].version\n\ngithub_badge = \"[![Github](https://img.shields.io/badge/JuliaQuantumControl-Krotov.jl-blue.svg?logo=github)](https://github.com/JuliaQuantumControl/Krotov.jl)\"\n\nversion_badge = \"![v$VERSION](https://img.shields.io/badge/version-v$VERSION-green.svg)\"\n\nMarkdown.parse(\"$github_badge $version_badge\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Implementation of Krotov's method of optimal control enhanced with automatic differentiation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Part of QuantumControl.jl and the JuliaQuantumControl organization.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Krotov.jl is a port of the krotov Python package, adapted to the API  of QuantumControl.jl.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"overview.md\",\n]\nDepth = 1","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"examples/simple_state_to_state.md\",\n    \"examples/rho_3states.md\",\n    \"examples/state_to_state_parametrizations.md\",\n    \"examples/perfect_entanglers.md\",\n]\nDepth = 1","category":"page"},{"location":"","page":"Home","title":"Home","text":"See also the general examples of the QuantumControl package.","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"api.md\",\n]\nDepth = 1","category":"page"},{"location":"#History","page":"Home","title":"History","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the Releases on Github.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
